# FPGA Tools

The Python based scripts provide access to the VCU118 FPGA board.

### Prerequisites

- Python3
- Xilinx Vivado (for bitfile upload)
- RISC-V compiler (to compile code for target processor)
- Ethernet (UDP) connection

## The VCU118 FPGA Board [1]

### Switches and LEDs

- Pushbutton CPU_RESET (SW5): FPGA system reset (reinitialize all registers and clocks)
- GPIO DIP Switch (SW12): The four DIP switches DIP_SW[3:0] set the IP and the MAC address of the FPGA board.
- GPIO LEDs (next to power on/off switch):
  - LED0: flashes when SW5 is pushed (system reset)
  - LED1: Ethernet connection, internal link is up and sync has been obtained
  - LED2: Ethernet connection, external link is up
  - LED3: DDR4 calibration done


## FPGA Top-level Architecture

The current FPGA top-level comprises a NoC with four routers while each router connects two tiles (PMs). In total there are 8 tiles:
- Ethernet interface
- UART interface
- 2x 2GB DDR4 DRAM
- 4x Rocket Core with TCU and 2MB local memory

All tiles and the NoC are clocked at a fixed frequency of 100MHz. The clocks are generated by an internal PLL (MMCME).

Each tile/PM has an assigned 8-bit Module-ID (modid) - defined in `fpga_tools/python/modids.py`:
```
PM0 - UART    - modid: 0x04
PM1 - ETH     - modid: 0x05
PM2 - DRAM1   - modid: 0x24
PM3 - ROCKET3 - modid: 0x25
PM4 - DRAM2   - modid: 0x20
PM5 - ROCKET4 - modid: 0x04
PM6 - ROCKET1 - modid: 0x21
PM7 - ROCKET2 - modid: 0x00
```

### Rocket Core [2]

The current Rocket Core was generated with the following features:
- RISC-V GC ISA
- 16kB L1 DCache, 16kB L1 ICache
- 512kB shared L2 Cache
- MMU with PTW, TLB
- FPU
- 2x external interrupt pin
- External memory interface connected to 2MB local SPM (currently used as DRAM)
- MMIO interface to access TCU registers from core
- Memory master interface for TCU to access memory (cache coherent)
- JTAG interface for debugging (currently unconnected)

The Rocket memory mapping is as follows:
```
Debug Controller: 0x00000000 - 0x00001000
Error Device:     0x00003000 - 0x00004000
BootROM:          0x00010000 - 0x00020000
CLINT:            0x02000000 - 0x02010000
Cache Controller: 0x02010000 - 0x02011000
PLIC:             0x0C000000 - 0x10000000
DRAM:             0x10000000 - 0xF0000000
MMIO:             0xF0000000 - 0xF1000000
```

Rocket boots in BootROM after enable signal was set and waits for external interrupt 0. When interrupt is triggered, core starts from 0x10000000 in DRAM.


### TCU

The current TCU version includes the following features:
- 64 endpoint registers
- Full unprivileged interface incl. registers and commands
- Full external interface incl. registers and commands
- TCU status info
- Core-specific registers

The current TCU version does _not_ support:
- Privileged interface incl. registers and commands
- Virtual memory
- PE sharing


The TCU status register (addr: `TCU_REGADDR_TCU_STATUS`) provides information about ongoing TCU commands:
```
Bit   | Description
-------------------
0     | WRITE or READ (send request packet)
1     | READ
2     | SEND
3     | RECEIVE
4     | REPLY
5     | FETCH
6     | ACK_MSG
7     | -
8-15  | State of NoC FSM
16-23 | State of Ctrl FSM
24-31 | -
```

The core-specific registers (addr: `TCU_REGADDR_CORE_CFG_START`) provides access to the core, e.g. enable, interrupts, address settings, etc.

> `fpga_tools/python/tcu.py` provides available TCU register addresses.
> `fpga_tools/python/pm.py` provides available register access functions.


## Running a testcase

Create a new directory in fpga_tools/testcases for your testcase. In this testcase directory should be at least a reference to the `fpga_tools/Makefile` and the python test file `testcase.py`. (see example `fpga_tools/testcases/tc_rocket_boot`)


### Connect the Ethernet cable

Plug in the Ethernet cable to the RJ-45 socket (J10) of the FPGA board and connect it to your host-PC. During FPGA startup IP and MAC addresses of FPGA and host-PC are exchanged via ARP.

IP and MAC addresses of the FPGA are set via DIP switch DIP_SW[3:0] (SW12). The value of DIP_SW[3:0] is added to the base IP `192.168.42.240` and MAC `0x080028030405`. For example, if DIP_SW = 0010b the resulting IP and MAC are 192.168.42.242 and 0x080028030407, respectively.


### Program the FPGA

Uploading the bitfile is done via an USB connection. Plug in the USB cable to the JTAG connector (J106) on the FPGA board and connect it to your host-PC. Additionally, Xilinx Vivado must be added to your environment.

Upload the latest bitfile. In a testcase directory run:
```shell
make program-fpga
```

Upload another bitfile:
```shell
make program-fpga BITFILE=path/to/bitfile
```

> Note: The "SCoHa"-FPGA is connected via USB to PC "synthesib". Hence, uploading the bitfile only works from this PC.
> 1) Login to "synthesib" with user `fpga` and password `fpga`.
> 2) Add Xilinx Vivado to the environment: `module add xilinx/vivado-2019.1`
> 3) Find the cloned Gitlab repo in the home directory including the Makefile and run the above commands.


### Compile code for the target processor

__NOTE - Deprecated section - Compile tool-flow migrated to M3-Repo__

Currently, the compile scripts only support 32-bit RISC-V cores:

- PicoRV32
- Codasip Bk3

Add your source files to a new folder (`src`) in the testcase directory.
In the testcase-specific Makefile, add compiler switches and settings to the variables.
In the testcase directory run:
```shell
make compile
```

You can also use your own toolchain. However, you still must generate the .hex file which contains the memory image for the target processor.

For example, for a RISC-V core you can use `elf2hex` [3]. The syntax is:
```shell
elf2hex <width> <depth> <elf_file> [base]
```

- width: memory data width (here always 8)
- depth: memory depth
- elf_file: object file of compiled program
- base: program start address

For example, the compiled program "main" needs max. 128kB memory while the code section (.text) starts at address 0x10000000:
```shell
elf2hex 8 16384 main 268435456
```

Note that elf2hex expects all input numbers as decimal numbers.

Afterwards, use `fpga_tools/scripts/reducehex.py` to remove unnecessary zeros in the .hex file. This shortens the time of the memory initialization.
```shell
python3 reducehex.py input.hex output.hex
```

The file `fpga_tools/scripts/make_hex` shows an example of the last two commands.


### Run the testcase

Edit the `testcase.py` accordingly. In the testcase directory run:

```shell
make run
```


## References

[1] User Guide VCU118 Evaluation Board: https://www.xilinx.com/support/documentation/boards_and_kits/vcu118/ug1224-vcu118-eval-bd.pdf

[2] Rocket Chip at Github: https://github.com/chipsalliance/rocket-chip

[3] "elf2hex" is part of the RISC-V toolchain: https://github.com/riscv/riscv-gnu-toolchain

