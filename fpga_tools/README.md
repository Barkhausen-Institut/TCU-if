# FPGA Tools

The Python based scripts provide access to the VCU118 FPGA board.

### Prerequisites

- Python3
- Xilinx Vivado (for bitfile upload)
- RISC-V compiler (to compile code for target processor)
- Ethernet (UDP) connection

## The VCU118 FPGA Board [1]

### Switches and LEDs

- Pushbutton CPU_RESET (SW5): FPGA system reset (reinitialize all registers and clocks)
- GPIO DIP Switch (SW12): The four DIP switches DIP_SW[3:0] set the IP and the MAC address of the FPGA board.
- GPIO LEDs (next to power on/off switch):
  - LED0: flashes when SW5 is pushed (system reset)
  - LED1: Ethernet connection, internal link is up and sync has been obtained
  - LED2: Ethernet connection, external link is up
  - LED3: DDR4 calibration done


## FPGA Top-level Architecture

The current FPGA top-level comprises a NoC with four routers while each router connects three tiles (PMs). In total there are 12 tiles:
- Ethernet interface
- UART interface (directly connected to Rocket core from bitfile v4.3)
- 2x 2GB DDR4 DRAM
- 8x Rocket Core with TCU

All tiles with Rocket cores and the NoC are clocked at a fixed frequency of 100MHz. BOOM cores are clocked at 80MHz. The clocks are generated by an internal PLL (MMCME).

Each tile/PM has an assigned 8-bit Module-ID (modid) - defined in `fpga_tools/python/modids.py`:
```
TILE0  - UART    - modid: 0x04
TILE1  - ETH     - modid: 0x05
TILE2  - ROCKET0 - modid: 0x06
TILE3  - DRAM1   - modid: 0x24
TILE4  - ROCKET1 - modid: 0x25
TILE5  - ROCKET2 - modid: 0x26
TILE6  - ROCKET3 - modid: 0x00
TILE7  - ROCKET4 - modid: 0x01
TILE8  - ROCKET5 - modid: 0x02
TILE9  - ROCKET6 - modid: 0x20
TILE10 - ROCKET7 - modid: 0x21
TILE11 - DRAM2   - modid: 0x22
```

### Rocket Core [2]

The current Rocket Core was generated with the following features:
- RISC-V GC ISA
- 16kB L1 DCache, 16kB L1 ICache
- 512kB shared L2 Cache
- MMU with PTW, TLB
- FPU
- 8x external interrupt pin
- External memory interface connected via TCU PMP and NoC to external DRAM
- MMIO interface to access TCU registers from core
- Memory master interface for TCU to access memory (cache coherent)
- JTAG interface for debugging

The Rocket memory mapping is as follows:
```
Debug Controller: 0x00000000 - 0x00001000
Error Device:     0x00003000 - 0x00004000
BootROM:          0x00010000 - 0x00020000
Trace Mem:        0x00100000 - 0x00108000
CLINT:            0x02000000 - 0x02010000
Cache Controller: 0x02010000 - 0x02011000
PLIC:             0x0C000000 - 0x10000000
DRAM:             0x10000000 - 0xF0000000
MMIO:             0xF0000000 - 0xF1000000
```

Rocket boots in BootROM after enable signal was set and waits for external interrupt 0. When interrupt is triggered, core starts from 0x10000000 in DRAM.
BOOM cores are the out-of-order variants of Rocket cores but include the memory features and interfaces.

### Ethernet FMC Card [3]

The Quad Gigabit Ethernet FMC Card allows to connect up to four additional Ethernet cables (RJ45) via the FMC HPC connector to the VCU118 board. The Ethernet interfaces are used to connect other devices to the MPSoC platform via a TCP/IP connection.
Together with the Rocket core (or BOOM) and the TCU, the correspoding Ethernet IP block design is integrated into a processing tile.


### TCU

The current TCU version includes the following features:
- 128 endpoint registers
- Full unprivileged interface incl. registers and commands
- Full external interface incl. registers and commands
- Privileged interface incl. registers and commands
- Virtual memory
- PE sharing
- TCU status info
- TCU logging
- Core-specific registers


The TCU status register (addr: `TCU_REGADDR_TCU_STATUS`) provides information about ongoing TCU commands:
```
Bit   | Description
-------------------
0     | WRITE
1     | READ
2     | READ (send read request)
3     | SEND
4     | RECEIVE
5     | REPLY
6     | FETCH
7     | ACK_MSG
8-15  | State of NoC FSM
16-23 | State of Ctrl FSM
24-31 | State of Ext-Ctrl FSM
```

The core-specific registers (addr: `TCU_REGADDR_CORE_CFG_START`) provides access to the core, e.g. enable, interrupts, address settings, etc.

> `fpga_tools/python/tcu.py` provides available TCU register addresses.
> `fpga_tools/python/pm.py` provides available register access functions.


## Running a testcase

Create a new directory in fpga_tools/testcases for your testcase. In this testcase directory should be at least a reference to the `fpga_tools/Makefile` and the python test file `testcase.py`. (see example `fpga_tools/testcases/tc_rocket_boot`)


### Connect the Ethernet cable

Plug in the Ethernet cable to the RJ-45 socket (J10) of the FPGA board and connect it to your host-PC. During FPGA startup IP and MAC addresses of FPGA and host-PC are exchanged via ARP.

IP and MAC addresses of the FPGA are set via DIP switch DIP_SW[3:0] (SW12). The value of DIP_SW[3:0] is added to the base IP `192.168.42.240` and MAC `0x080028030405`. For example, if DIP_SW = 0010b the resulting IP and MAC are 192.168.42.242 and 0x080028030407, respectively.


### Program the FPGA

Uploading the bitfile is done via an USB connection. Plug in the USB cable to the JTAG connector (J106) on the FPGA board and connect it to your host-PC. Additionally, Xilinx Vivado must be added to your environment.

Upload the latest bitfile. In a testcase directory run:
```shell
make program-fpga
```

Upload another bitfile:
```shell
make program-fpga BITFILE=path/to/bitfile
```

> Note: The "SCoHa"-FPGA is connected via USB to PC "synthesib". Hence, uploading the bitfile only works from this PC.
> 1) Login to "synthesib" with user `fpga` and password `fpga`.
> 2) Add Xilinx Vivado to the environment: `module add xilinx/vivado-2019.1`
> 3) Find the cloned Gitlab repo in the home directory including the Makefile and run the above commands.


### Compile code for the target processor

__NOTE - Deprecated section - Compile tool-flow migrated to M3-Repo__

Currently, the compile scripts only support 32-bit RISC-V cores:

- PicoRV32
- Codasip Bk3

Add your source files to a new folder (`src`) in the testcase directory.
In the testcase-specific Makefile, add compiler switches and settings to the variables.
In the testcase directory run:
```shell
make compile
```

You can also use your own toolchain. However, you still must generate the .hex file which contains the memory image for the target processor.

For example, for a RISC-V core you can use `elf2hex` [4]. The syntax is:
```shell
elf2hex <width> <depth> <elf_file> [base]
```

- width: memory data width (here always 8)
- depth: memory depth
- elf_file: object file of compiled program
- base: program start address

For example, the compiled program "main" needs max. 128kB memory while the code section (.text) starts at address 0x10000000:
```shell
elf2hex 8 16384 main 268435456
```

Note that elf2hex expects all input numbers as decimal numbers.

Afterwards, use `fpga_tools/scripts/reducehex.py` to remove unnecessary zeros in the .hex file. This shortens the time of the memory initialization.
```shell
python3 reducehex.py input.hex output.hex
```

The file `fpga_tools/scripts/make_hex` shows an example of the last two commands.


### Run the testcase

Edit the `testcase.py` accordingly. In the testcase directory run:

```shell
make run
```


## References

[1] User Guide VCU118 Evaluation Board: https://www.xilinx.com/support/documentation/boards_and_kits/vcu118/ug1224-vcu118-eval-bd.pdf

[2] Rocket Chip at Github: https://github.com/chipsalliance/rocket-chip

[3] Opsero: Quad Gigabit Ethernet FPGA Mezzanine Card, https://opsero.com/product/ethernet-fmc/

[4] "elf2hex" is part of the RISC-V toolchain: https://github.com/riscv/riscv-gnu-toolchain

