\chapter{System Overview}
\label{sec:systemoverview}

\newcommand{\fillpe}[3]{
    \node[below=.6em of pe#1.north] {#2};
    \node[cu, above right=.6em and .6em of pe#1.south west,#3] (cu#1) {CU};
    \node[tcu,above left=.6em and .6em of pe#1.south east,#3] (tcu#1) {TCU};

    \draw[noc] ($(pe#1.south west)-(0,1.0em)$) -- ($(pe3.south east)-(0,1.0em)$);
    \draw[noc] ($(pe#1.south west)-(0,1.2em)$) -- ($(pe3.south east)-(0,1.2em)$);
    \draw[noc] ($(pe#1.south west)-(0,1.4em)$) -- ($(pe3.south east)-(0,1.4em)$);

    \draw
      let \p1=(tcu#1.south), \p2=($(pe#1.south west)-(0,1.2em)$) in
      (tcu#1.south) -- (\x1, \y2);
    \fill[radius=.2em]
      let \p1=(tcu#1.south), \p2=($(pe#1.south west)-(0,1.2em)$) in
      (\x1, \y2) circle node {};
}

\begin{figure}[h]
  \center
  \begin{tikzpicture}[
      pe/.style={draw=gray,minimum width=9.5em,minimum height=8em},
      cu/.style={draw=gray,fill=red!50,minimum width=4.5em,minimum height=4.5em},
      tcu/.style={draw=gray,fill=green!50,minimum width=3em,minimum height=3em},
      noc/.style={draw=green},
    ]

    \node[pe] (pe1) {};
    \node[pe,right=2em of pe1] (pe2) {};
    \node[pe,right=2em of pe2] (pe3) {};

    \fillpe{1}{Kernel PE}{fill=green!50};
    \fillpe{2}{User PE}{};
    \fillpe{3}{User PE}{};

    \node[draw=black, fill=white,
          below right=.3em and .3em of cu2.north west,
          minimum width=3.9em, minimum height=3.9em] {App};

    \node[draw=black, fill=white,
          below right=.3em and .3em of cu3.north west,
          minimum width=1.8em, minimum height=1.8em] (app1) {\tiny App};
          \node[draw=black, fill=white,
          right=.3em of app1.east,
          minimum width=1.8em, minimum height=1.8em] (app2) {\tiny App};
    \node[draw=black, fill=white,
          above right=.3em and .3em of cu3.south west,
          minimum width=3.9em, minimum height=1.8em] (pex) {Priv};
    \node[draw=black, fill=pemux, above left=.3em and .3em of tcu3.south east] {};
    \node[draw=black, fill=vm, above left=.3em and 1.2em of tcu3.south east] {};

  \end{tikzpicture}
  \caption{System Overview.}
  \label{fig:sysoverview}
\end{figure}

\noindent The trusted communication unit~(TCU) is a building block that can be used to construct
secure systems. As shown in \rref{fig:sysoverview}, the system consists of multiple processing
elements~(PEs), each containing a compute unit~(CU) and a TCU. The PEs are linked through some
interconnect (e.g., a network-on-chip) and are split into \emph{kernel PEs} and \emph{user PEs}. The
former are privileged and manage the TCUs of the user PEs, whereas the latter are unprivileged.

In this system, the TCU, the interconnect, and the kernel PEs are trusted (shown green), whereas the
CUs in the user PEs are untrusted (shown red). By default, all PEs are isolated from each other, but
communication channels between PEs can be established. These communication channels can only be
establish by kernel PEs, but can be used afterwards by user PEs. Which PEs are kernel PEs is defined
by the TCU's \texttt{FEATURES} register. At boot, all PEs are kernel PEs, which can be changed by
the kernel booting on one specific PE before the other PEs start.

User PEs can have different complexities, mostly driven by the used CU. The left user PE uses a
simple core with scratchpad memory and a basic TCU without extensions. The right user PE uses a
complex core with caches and virtual memory support and a privileged software (Priv) that enables
multiple applications on the same PE and/or virtual memory. These features require TCU extensions
for virtual memory (\extbox{vm}) and/or PE sharing (\extbox{pemux}). This specification highlights
the portions that are required by only one extension in its color and portions that are required by
either extension as \extbox{vmpex}.

\section{Processing Elements}

\begin{figure}[h]
  \center
  \begin{tikzpicture}[
      tcureg/.style={draw=gray,fill=white,minimum width=2.6cm},
      regtbl/.style={draw=black,fill=gray!30,minimum width=3cm}
    ]

    \node[draw=black,minimum width=7cm,minimum height=7cm,anchor=north west] (tcu) at(4,0) {};
    \node[draw=black,minimum width=3.4cm,minimum height=3.2cm,anchor=north west] (cu) at (0,0) {CU};
    \node[draw=black,minimum width=3.4cm,minimum height=3.2cm,anchor=south west] (mem) at (0,-7) {SPM/Cache};

    \node[below right=.1cm and .1cm of tcu.north west] {TCU};

    \node[
      regtbl,below right=.8cm and .2cm of tcu.north west,minimum height=2cm
    ] (tcuregs) {};
    \node[below=.1cm of tcuregs.north] {ExtRegs};
    \node[tcureg,below=.7cm of tcuregs.north] (extreg0) {\texttt{FEATURES}};
    \node[tcureg,below=0cm of extreg0]        (extreg1) {\texttt{EXT\_CMD}};

    \node[
      regtbl,below=1cm of tcuregs.south,minimum height=3cm
    ] (cmdregs) {};
    \node[below=.1cm of cmdregs.north] {UnprivRegs};
    \node[tcureg,below=.7cm of cmdregs.north] (cmdreg0) {\texttt{COMMAND}};
    \node[tcureg,below=0cm of cmdreg0]        (cmdreg1) {\texttt{DATA}};
    \node[tcureg,below=0cm of cmdreg1]        (cmdreg2) {\texttt{ARG$_1$}};
    \node[tcureg,below=0cm of cmdreg2]        (cmdreg3) {\texttt{CUR\_TIME}};

    \node[
      regtbl,below left=1cm and .4cm of tcu.north east,minimum height=2.6cm
    ] {};
    \node[
      regtbl,below left=.9cm and .3cm of tcu.north east,minimum height=2.6cm
    ] {};
    \node[
      regtbl,below left=.8cm and .2cm of tcu.north east,minimum height=2.6cm
    ] (epregs) {};
    \node[below=.1cm of epregs.north] {EpRegs};
    \node[tcureg,below=.7cm of epregs.north] (epreg0) {\texttt{EP$_0$}};
    \node[tcureg,below=0cm of epreg0]        (epreg1) {\texttt{EP$_1$}};
    \node[tcureg,below=0cm of epreg1]        (epreg2) {\texttt{EP$_2$}};

    \node[
      regtbl,fill=vmpex,below right=0cm and .38cm of cmdregs.north east,minimum height=3cm
    ] (prvregs) {};
    \node[below=.1cm of prvregs.north] {PrivRegs};
    \node[tcureg,below=.7cm of prvregs.north] (prvreg0) {\texttt{CORE\_REQ}};
    \node[tcureg,below=0cm of prvreg0]        (prvreg1) {\texttt{PRIV\_CMD}};
    \node[tcureg,below=0cm of prvreg1]        (prvreg2) {\texttt{PRIV\_CMD\_ARG}};
    \node[tcureg,below=0cm of prvreg2]        (prvreg3) {\texttt{CUR\_VPE}};

    \path
      let \p1=(cu.east), \p2=(tcu.west) in
      [draw=black,thick,->] (cu.east) -- (\x2,\y1);
    \path[draw=black,thick,->] (cu) -- (mem);
    \path
      let \p1=(mem.east), \p2=(tcu.west) in
      [draw=black,thick,<-] (mem.east) -- (\x2,\y1);
  \end{tikzpicture}
  \caption{The internal organization of a PE.}
  \label{fig:peinternal}
\end{figure}

\rref{fig:peinternal} shows the internals of a processing element~(PE). The compute unit~(CU) is
connected to the trusted communication unit~(TCU) and can access the TCU's registers via memory
mapped input/output (MMIO). Additionally, the CU is connected to the local memory. The TCU is also
connected to the local memory (SPM or cache) to, for example, access messages. These components are
not necessarily arranged in this way. For example, the TCU might interpose itself between the CU and
local memory.

To support the security model introduced in \rref{sec:systemoverview}, the registers are split into
different groups, each group having different access permissions. All registers are generally
readable. \emph{External registers} can only be written externally, that is, from a remote PE. They
are intended for the kernel PE to manipulate the state of remote TCUs. \emph{Endpoint registers} can
be written externally and locally by the kernel PE. \emph{Unprivileged registers} can be written by
the CU. In consequence, only kernel PEs can \emph{establish} communication channels by writing
endpoint registers, but user PEs can \emph{use} these communication channels through the
unprivileged registers.

\extstart{vmpex} The \emph{privileged registers} are intended for privileged software running on PEs
that are multiplexed among multiple VPEs and/or use virtual memory. The privileged software should
make sure that unprivileged software running on the same PE cannot access the privileged registers.
\extend{}

\section{Registers}

The TCU has several registers that are accessible through memory-mapped input/output~(MMIO). The
memory interface from CU to TCU is expected to be 64-bit wide. The MMIO region of the TCU is defined
as follows:

\vspace{2ex}
\noindent
\begin{tabular}{ p{3cm} | c | c | l }
  \textbf{Address} & \textbf{Register} & \textbf{Group} & \textbf{Description} \\
  \hline
  \hline
  \texttt{0xF000\_0000} & \texttt{FEATURES} & ExtRegs & Contains feature flags \\
  \hline
  \texttt{0xF000\_0008} & \texttt{EXT\_CMD} & ExtRegs & Triggers external commands \\
  \hline
  \hline
  \texttt{0xF000\_0010} & \texttt{COMMAND} & UnprivRegs & Triggers unprivileged commands \\
  \hline
  \texttt{0xF000\_0018} & \texttt{DATA} & UnprivRegs & Specifies the data for commands \\
  \hline
  \texttt{0xF000\_0020} & \texttt{ARG$_1$} & UnprivRegs & Additional argument for commands \\
  \hline
  \texttt{0xF000\_0028} & \texttt{CUR\_TIME} & UnprivRegs & Yields the current time in nanoseconds \\
  \hline
  \texttt{0xF000\_0030} & \emph{reserved} & UnprivRegs & Reserved for future use (\texttt{PRINT} in gem5) \\
  \hline
  \hline
  \texttt{0xF000\_0038} & \texttt{EP$_{00}$} & EpRegs & First register of EP$_0$ \\
  \texttt{0xF000\_0040} & \texttt{EP$_{01}$} & EpRegs & Second register of EP$_0$ \\
  \texttt{0xF000\_0048} & \texttt{EP$_{02}$} & EpRegs & Third register of EP$_0$ \\
  \hline
  \texttt{0xF000\_0050} & \texttt{EP$_{10}$} & EpRegs & First register of EP$_1$ \\
  \texttt{0xF000\_0058} & \texttt{EP$_{11}$} & EpRegs & Second register of EP$_1$ \\
  \texttt{0xF000\_0060} & \texttt{EP$_{12}$} & EpRegs & Third register of EP$_1$ \\
  \hline
  \multicolumn{4}{c}{\dots} \\
  \hline
  \hline
  \texttt{0xF000\_2000} & \texttt{CORE\_REQ} & PrivRegs & TCU-core interactions \extstart{vmpex} \\
  \texttt{0xF000\_2008} & \texttt{PRIV\_CMD} & PrivRegs & Triggers privileged commands \\
  \texttt{0xF000\_2010} & \texttt{PRIV\_CMD\_ARG} & PrivRegs & Argument for privileged commands \extend{} \\
  \texttt{0xF000\_2018} & \texttt{CUR\_VPE} & PrivRegs & Currently running VPE \extstart{pemux} \extend{} \\
\end{tabular}\\[1em]

\section{Error List}

The TCU uses the following error codes to provide feedback to the software for failed commands:

\begin{itemize}
  \item \texttt{NONE} (0): no error (success),
  \item \texttt{NO\_MEP} (1): no memory endpoint,
  \item \texttt{NO\_SEP} (2): no send endpoint,
  \item \texttt{NO\_REP} (3): no receive endpoint,
  \item \texttt{FOREIGN\_EP} (4): the endpoint belongs to a different VPE,
  \item \texttt{SEND\_REPLY\_EP} (5): SEND command with a reply EP or REPLY with send EP,
  \item \texttt{RECV\_GONE} (6): receiver gone (received message at non-receive EP),
  \item \texttt{RECV\_MISALIGN} (7): receiver buffer not 8-byte aligned,
  \item \texttt{RECV\_NO\_SPACE} (8): receiver buffer full,
  \item \texttt{REPLIES\_DISABLED} (9): replies are disabled,
  \item \texttt{OUT\_OF\_BOUNDS} (10): the offset and/or size is out of bounds,
  \item \texttt{NO\_CREDITS} (11): no credits to send a message,
  \item \texttt{NO\_PERM} (12): insufficient permissions,
  \item \texttt{INV\_MSG\_OFF} (13): invalid message offset,
  \item \texttt{PAGEFAULT} (14): a pagefault occurred during a local transfer,
  \item \texttt{ABORT} (15): a command was aborted,
  \item \texttt{UNKNOWN\_CMD} (16): unknown command,
  \item \texttt{RECV\_OUT\_OF\_BOUNDS} (17): message too large for receive buffer,
  \item \texttt{RECV\_INV\_RPL\_EPS} (18): invalid reply EPs in receive EP,
  \item \texttt{SEND\_INV\_CRD\_EP} (19): invalid credit EP in send EP,
  \item \texttt{SEND\_INV\_MSG\_SZ} (20): invalid value in msg\_sz field ($> 11$),
  \item \texttt{RECV\_BUSY} (21): receiver is busy, sender should retry the command.
\end{itemize}
