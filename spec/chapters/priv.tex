\chapter{Privileged Interface}

The privileged interface of the TCU adds support for virtual memory and PE sharing to the TCU and is
thus only required if either of these features are desired. Thus, all non-highlighted functionality
is required if either extension is used, whereas the highlighted functionality is only required for
one specific extension.

The interface consists of multiple privileged registers, privileged commands, and \emph{core
requests}, which are raised by the TCU and answered by the privileged software. To support the
privileged software in the management of multiple VPEs or virtual memory, privileged commands are
used, which can be performed by writing to \texttt{PRIV\_CMD}. The register is defined as follows:

\begin{register}{H}{PRIV\_CMD}{\texttt{0xF000\_2008}}
  \regfieldb{arg}{55}{9}%
  \regfieldb{err}{5}{4}%
  \regfieldb{op}{4}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[arg] the argument for the privileged command
    \item[err] the result of the operation (output field)
    \item[op] the opcode of the privileged command
  \end{reglist}\end{regdesc}
\end{register}

\noindent Note that none of the privileged commands can currently fail. Thus, only unknown command
opcodes lead to \texttt{err} being set to an a non-zero value.

\extstart{pemux}
\noindent The TCU stores the id of the current VPE including the number of unread messages in all
its receive EPs in the \texttt{CUR\_VPE} register:

\setlength{\regWidth}{.95\textwidth}
\begin{register}{H}{CUR\_VPE}{\texttt{0xF000\_2018}}
  \regfield[gray!20]{reserved}{32}{32}{{uninitialized}}%
  \regfield{msgs}{16}{16}{0}%
  \regfield{id}{16}{0}{1111111111111111}%
  \reglabel{Reset}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[msgs] the sum of all unread messages in the receive EPs for this VPE
    \item[id] the VPE id
  \end{reglist}\end{regdesc}
\end{register}
\setlength{\regWidth}{\textwidth}
\extend{}

\section{Command List}

The following privileged commands are supported with the opcodes in parentheses. Other opcodes lead
to an \texttt{UNKNOWN\_CMD} error.

\begin{itemize}
  \item \texttt{IDLE} (0): \extstart{vmpex} don't do anything, \extend{}
  \item \texttt{INV\_PAGE} (1): invalidate a page in the TLB, \extstart{vm}
  \item \texttt{INV\_TLB} (2): invalidate the complete TLB,
  \item \texttt{INS\_TLB} (3): insert an entry into the TLB, \extend{}
  \item \texttt{XCHG\_VPE} (4): change the VPE, \extstart{pemux}
  \item \texttt{SET\_TIMER} (5): start/stop the timer,
  \item \texttt{ABORT\_CMD} (6): abort the unprivileged command. \extend{}
\end{itemize}

\section{Pseudo Code Building Blocks}

The following sections use pseudo code to describe the behavior of the privileged commands, based on
several building blocks:

\begin{itemize}
  \item \texttt{insert\_tlb\_entry(vpe, virt, phys, flags)}: \extstart{vm}\\
  inserts an entry from \texttt{virt} to \texttt{phys} into the TLB for given VPE
  \item \texttt{remove\_tlb\_entry(vpe, virt)}:\\
  removes the entry with \texttt{virt} for given VPE
  \item \texttt{clear\_tlb()}:\\
  removes all entries from the TLB \extend{}
  \item \texttt{set\_timer(timeout)}: \extstart{pemux}\\
  starts/restarts the timer to fire an interrupt after \texttt{timeout} nanoseconds
  \item \texttt{unset\_timer()}:\\
  stops the timer
  \item \texttt{waiting\_for\_resp() -> bool}:\\
  returns whether the TCU is currently waiting for a remote TCU's response (to \texttt{SEND},
  \texttt{REPLY}, \texttt{READ}, or \texttt{WRITE})
  \item \texttt{wait\_for\_resp()}:\\
  waits until a remote TCU responds (to \texttt{SEND}, \texttt{REPLY}, \texttt{READ}, or
  \texttt{WRITE})
  \item \texttt{abort\_remote\_xfer()}:\\
  lets the current remote transfer fail, so that \texttt{read\_remote} or \texttt{write\_remote}
  return the \texttt{ABORT} error (see \rref{sec:unprivcmdspseudo})
  \item \texttt{abort\_local\_xfer() -> bool}:\\
  checks if there is a local transfer (for the current unprivileged command) and if so, aborts it,
  so that \texttt{read\_local()} or \texttt{write\_local()} return the \texttt{ABORT} error (see
  \rref{sec:unprivcmdspseudo}). Returns true if it was aborted.
  \item \texttt{resume\_local\_xfer()}:\\
  resumes a previously paused local transfer (due to an address translation). \extend{}
\end{itemize}

\section{Command Description}

\extstart{vm}
\subsection{\texttt{INV\_PAGE}}

\begin{algorithm}[H]
    \colorbox{pemux}{$vpe \gets PRIV\_CMD.arg0 >> 32$}\;
    $virt\_page\_no \gets (PRIV\_CMD.arg0\ \&\ 0xFFFF\_F000) >> 12$\;
    \BlankLine
    $remove\_tlb\_entry(\colorbox{pemux}{vpe, }virt\_page\_no)$\;
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{INV\_PAGE} command.}
\end{algorithm}

\noindent Note that \texttt{INV\_PAGE} invalidates the entry regardless of whether with flag
\texttt{FIXED} is set or not.

\subsection{\texttt{INV\_TLB}}

\begin{algorithm}[H]
    $clear\_tlb()$\;
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{INV\_TLB} command.}
\end{algorithm}

\subsection{\texttt{INS\_TLB}}

\begin{algorithm}[H]
    \colorbox{pemux}{$vpe \gets PRIV\_CMD.arg0 >> 32$}\;
    $virt\_page\_no \gets (PRIV\_CMD.arg0\ \&\ 0xFFFF\_F000) >> 12$\;
    $flags \gets PRIV\_CMD.arg0\ \&\ 0x1F$\;
    $phys\_page\_no \gets (PRIV\_CMD\_ARG1\ \&\ 0xFFFF\_F000) >> 12$\;
    \BlankLine
    $insert\_tlb\_entry(\colorbox{pemux}{vpe, }virt\_page\_no, phys\_page\_no, flags)$\;
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{INS\_TLB} command.}
\end{algorithm}
\extend{}

\subsection{\texttt{XCHG\_VPE}}
\extstart{pemux}

\begin{algorithm}[H]
    $PRIV\_CMD\_ARG1 \gets CUR\_VPE$\;
    $CUR\_VPE \gets PRIV\_CMD.arg0\ \&\ 0xFFFF\_FFFF$\;
    \BlankLine
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{XCHG\_VPE} command.}
\end{algorithm}

\subsection{\texttt{SET\_TIMER}}

\begin{algorithm}[H]
    $nanos \gets PRIV\_CMD.arg0$\;
    \uIf{nanos == 0}{
      $unset\_timer()$\;
    }
    \uElse{
      $set\_timer(nanos)$\;
    }
    \BlankLine
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{SET\_TIMER} command.}
\end{algorithm}

\subsection{\texttt{ABORT\_CMD}}

\begin{algorithm}[H]
    \uIf{COMMAND.op != 0}{
      \uIf{waiting\_for\_resp()}{
        \uIf{COMMAND.op == READ or COMMAND.op == WRITE}{
          $PRIV\_CMD.arg0 \gets 1$\;
          $abort\_remote\_xfer()$\;
        }
        $wait\_for\_resp()$\;
      }
      \uElseIf{abort\_local\_xfer()}{
        $PRIV\_CMD.arg0 \gets 1$\;
      }
    }
    \BlankLine
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{ABORT\_CMD} command.}
\end{algorithm}

\section{Core Requests}

With PE sharing, the TCU needs assistance of the CU if a message for another VPE than the currently
running VPE (\texttt{CUR\_VPE}) is received. Since we assume in this case that the CU is a
general-purpose core, these requests for assistance are called \emph{core requests}.

Since multiple core requests might occur simultaneously, the TCU keeps a queue of pending core
requests and handles them in FIFO order. To handle the first in the queue, the TCU writes to
\texttt{CORE\_REQ} and injects an interrupt to inform the core about the request. After the handling
of the core request, the core is expected to write to \texttt{CORE\_REQ} again to signal the
completion of the request. Upon receiving this signal, as described in \rref{code:corereqfinish},
the TCU starts the next core request, if there is any. New core requests, as described in
\rref{code:corereqstart}, are appended to the queue via \texttt{queue\_foreign\_msg\_req()} and
started, if possible.

\subsection{Pseudo Code}

The following pseudo code describes the TCU's behavior regarding core requests in more detail.

\begin{algorithm}[H]
    \SetKwFunction{FMain}{queue\_foreign\_msg\_req}
    \SetKwProg{Fn}{Function}{:}{}
    \Fn{\FMain{$vpe$, $ep$}}{
      $queue.enqueue(vpe\ |\ ep\ |\ 2)$\;
      $try\_start\_req()$\;
    }
    \textbf{End Function}
    \BlankLine

    \SetKwFunction{FMain}{try\_start\_req}
    \SetKwProg{Fn}{Function}{:}{}
    \Fn{\FMain{}}{
      \uIf{CORE\_REQ.type == 0 and not queue.empty()}{
        $CORE\_REQ \gets queue.front()$\;
      }
    }
    \textbf{End Function}
    \caption{Enqueuing and starting of core requests.}
    \label{code:corereqstart}
\end{algorithm}

\begin{algorithm}[H]
    \uIf{CORE\_REQ.type == 1 and not queue.empty()}{
      $cur = queue.dequeue()$\;
      $CORE\_REQ \gets 0$\;
      \BlankLine
      $try\_start\_req()$\;
    }
    \caption{Dequeuing and finishing of core requests.}
    \label{code:corereqfinish}
\end{algorithm}

\subsection{Registers}

\begin{register}{H}{CORE\_REQ}{\texttt{0xF000\_2000}}
  \regfieldb[gray!60]{}{62}{2}%
  \regfieldb{type}{2}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[type] the type (0 = idle, 1 = response, 2 = foreign message)
  \end{reglist}\end{regdesc}
\end{register}

\noindent As the \texttt{CORE\_REQ} register is used for different kinds of requests and responses,
most of the bits depend on the type of request/response, defined in the following.

\begin{register}{H}{CORE\_REQ for foreign message requests}{\texttt{0xF000\_2000}}
  \regfieldb{vpe}{16}{48}%
  \regfieldb[gray!20]{reserved}{30}{18}%
  \regfieldb{ep}{16}{2}%
  \regfieldb{type}{2}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[ep] the receive EP which received a message
    \item[vpe] the VPE that received the message
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{CORE\_REQ for foreign message responses}{\texttt{0xF000\_2000}}
  \regfieldb[gray!20]{reserved}{62}{2}%
  \regfieldb{type}{2}{0}\regnewline%
\end{register}
\extend{}

\extstart{vm}
\section{Translation Look-aside Buffer}
\label{sec:tlb}

With virtual memory support, the TCU maintains a TLB to cache recent address translations. These
translations are exclusively used for local transfers and thus always explicitly triggered by the
software on the CU via TCU commands. The privileged software is responsible to remove entries from
the TLB when pages get unmapped from the application's virtual address space or if page permissions
were downgraded. Additionally, the TCU can assume that TLB entries stay valid during the complete
execution of a command. In other words, the privileged software is responsible to abort a
potentially running command when removing entries from the TLB to ensure that it is not used
anymore.

The TLB contains a 20-bit virtual page number (virtual address shifted right by 12 bits),
\colorbox{pemux}{16-bit VPE id, }20-bit physical page number (physical address shifted right by 12
bits), and 5 bits for permissions. Small pages are 4~KiB and large pages 2~MiB. The virtual and
physical address are always page-size aligned. The permissions are defined as follows:

\begin{itemize}
  \item \texttt{READ} (1): read permission,
  \item \texttt{WRITE} (2): write permission,
  \item \texttt{EXEC} (4): execute permission \todo{remove that?},
  \item \texttt{LARGE} (8): large page mapping,
  \item \texttt{FIXED} (16): fixed entry, will not be evicted.
\end{itemize}

\section{Physical Memory Protection}

\noindent With virtual memory support, PEs get access to a shared physical memory. The mapping from
virtual to physical memory is performed by privileged software on each PE. To prevent that this
privileged software and the CU within the PE is part of the trusted computing base (as it can access
all physical memory without further measures), the TCU supports physical memory protection.

The physical memory of each PE is split into multiple fixed-sized regions, whereas each region is
protected by a memory EP. The current implementation uses four regions of 1~GiB each and thus uses
the upper two bits of the physical address to determine the memory EP. In other words, the first
four EPs define to which parts of external memories the PE has access and also defines the access
permissions (read and/or write).

Instead of connecting the last-level cache~(LLC) directly to the NoC, the LLC is connected to the
TCU's physical memory protection, which validates and translates the address before passing it to
the NoC. The following pseudo code describes this process:\\[.2em]

\begin{algorithm}[H]
    \SetKwFunction{FMain}{llc\_miss}
    \SetKwProg{Fn}{Function}{:}{}
    \Fn{\FMain{$phys$, $size$, $access$}}{
      $addr \gets phys - 0x10000000$\;
      $epid \gets addr >> 30$\;
      $off \gets addr\ \&\ 0x3FFFFFFF$\;
      $ep \gets$ read\_ep(epid)\;
      \uIf{ep.type != MEMORY}{ignore access}
      \uIf{ep.rw \& access == 0}{ignore access}
      \uIf{off + size > ep.size}{ignore access}
      \BlankLine
      \uIf{access == READ}{
        $read\_remote(ep.PE, ep.addr + off, size)$\;
      }
      \uElse{
        $write\_remote(data, ep.PE, ep.addr + off, size)$\;
      }
    }
    \textbf{End Function}
    \caption{The validation and translation of physical addresses.}
    \label{code:pmp}
\end{algorithm}

\noindent The function \texttt{llc\_miss} above is called for each LLC miss and validates whether
the memory access is allowed before performing the memory access. The first parameter specifies the
physical address, the second parameter specifies the cache-line size, and the third parameter
specifies whether the access reads from memory or writes to memory. Note that the current
implementation substracts \texttt{0x10000000} from the physical access, because the Rocket Core maps
the DRAM to that address.
\extend{}
