% option draft um zu lange Zeilen anzuzeigen
\documentclass[a4paper,11pt,draft]{article}

\usepackage[inner=3cm,outer=3cm]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
% linux libertine for normal text
\usepackage{libertine}
\usepackage{libertinust1math}
% inconsolate as teletype font
\usepackage{inconsolata}
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathastext}
\usepackage{subcaption}
\usepackage{pmboxdraw}
\usepackage{lipsum}
\usepackage[export]{adjustbox}
\usepackage{csquotes}
\usepackage{tabularx}
\usepackage[sort]{natbib}
\usepackage[toc,nonumberlist]{glossaries}
\usepackage{makecell}
\usepackage[absolute,overlay]{textpos}
\usepackage{microtype}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage[color]{register}

\renewcommand{\regBitWidth}{64}
\setlength{\regWidth}{\textwidth}

% setup of siunitx
\usepackage[binary-units=true]{siunitx}
\DeclareSIUnit{\bits}{bits}
\DeclareSIUnit{\cycle}{cycle}
\DeclareSIUnit{\cycles}{cycles}
\sisetup{
  list-final-separator = {, and },
  per-mode=symbol
}

% tikz
\usepackage{tikz}
\usepackage{tikz-uml}
\usetikzlibrary{arrows,automata,positioning}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{calc}
\usetikzlibrary{intersections}
\usetikzlibrary{patterns}

% tikz setup
\usepackage{environ}
\makeatletter
\newsavebox{\measure@tikzpicture}
\NewEnviron{scaletikzpicturetowidth}[1]{%
  \def\tikz@width{#1}%
  \def\tikzscale{1}\begin{lrbox}{\measure@tikzpicture}%
  \BODY
  \end{lrbox}%
  \pgfmathparse{#1/\wd\measure@tikzpicture}%
  \edef\tikzscale{\pgfmathresult}%
  \BODY
}

\makeatother
\tikzstyle{thick arrow}=[-{Latex[length=2mm]}]

% hyperlinks
\usepackage[hyphens]{url}
\usepackage{hyperref}
\hypersetup{
  pdfauthor   = {Nils Asmussen},
  pdftitle    = {TCU Specification},
  pdfborder   = {0 0 0 [0 0]},
  colorlinks  = false
}

% listings
\usepackage{listings}
\lstset{basicstyle=\small\ttfamily,breaklines=true}
\lstdefinestyle{myc++}{
  language=C++,
  morekeywords={size_t,ssize_t}
}

% ignore page group warnings
\pdfsuppresswarningpagegroup=1

% redefine some names
\addto\extrasenglish{%
  \renewcommand{\chapterautorefname}{Chapter}%
  \renewcommand{\sectionautorefname}{Section}%
  \renewcommand{\subsectionautorefname}{Section}%
  \renewcommand{\subsubsectionautorefname}{Section}%
}

% for smart references
\newcommand{\rref}[2][]{\autoref{#2}}

% names
\newcommand{\myos}{$\text{M}^\mathbf{3}$}
\newcommand{\myfs}{$\text{M}^\mathbf{3}$FS}

% TODOs
\newcommand{\todo}[1]{\fbox{\bfseries\sffamily\scriptsize\color{red}TODO: #1}}

\title{Trusted Communication Unit -- Specification}
\author{Nils Asmussen}
\date{\today}

\begin{document}

\maketitle

\section{Overview}

\begin{figure}[h]
  \center
  \begin{tikzpicture}[
      tcureg/.style={draw=gray,fill=white,minimum width=2.6cm},
      regtbl/.style={draw=black,fill=gray!30,minimum width=3cm}
    ]

    \node[draw=black,minimum width=7cm,minimum height=7cm,anchor=north west] (tcu) at(4,0) {};
    \node[draw=black,minimum width=3.4cm,minimum height=3.2cm,anchor=north west] (cu) at (0,0) {CU};
    \node[draw=black,minimum width=3.4cm,minimum height=3.2cm,anchor=south west] (mem) at (0,-7) {SPM/Cache};

    \node[below right=.1cm and .1cm of tcu.north west] {TCU};

    \node[
      regtbl,below right=.8cm and .2cm of tcu.north west,minimum height=2cm
    ] (tcuregs) {};
    \node[below=.1cm of tcuregs.north] {ExtRegs};
    \node[tcureg,below=.7cm of tcuregs.north] (extreg0) {\texttt{FEATURES}};
    \node[tcureg,below=0cm of extreg0]        (extreg1) {\texttt{EXT\_CMD}};

    \node[
      regtbl,below=1cm of tcuregs.south,minimum height=3cm
    ] (cmdregs) {};
    \node[below=.1cm of cmdregs.north] {UnprivRegs};
    \node[tcureg,below=.7cm of cmdregs.north] (cmdreg0) {\texttt{COMMAND}};
    \node[tcureg,below=0cm of cmdreg0]        (cmdreg1) {\texttt{DATA}};
    \node[tcureg,below=0cm of cmdreg1]        (cmdreg2) {\texttt{ARG$_1$}};
    \node[tcureg,below=0cm of cmdreg2]        (cmdreg3) {\texttt{CUR\_TIME}};

    \node[
      regtbl,below left=1cm and .4cm of tcu.north east,minimum height=2.6cm
    ] {};
    \node[
      regtbl,below left=.9cm and .3cm of tcu.north east,minimum height=2.6cm
    ] {};
    \node[
      regtbl,below left=.8cm and .2cm of tcu.north east,minimum height=2.6cm
    ] (epregs) {};
    \node[below=.1cm of epregs.north] {Ep};
    \node[tcureg,below=.7cm of epregs.north] (epreg0) {\texttt{EP$_0$}};
    \node[tcureg,below=0cm of epreg0]        (epreg1) {\texttt{EP$_1$}};
    \node[tcureg,below=0cm of epreg1]        (epreg2) {\texttt{EP$_2$}};

    \path
      let \p1=(cu.east), \p2=(tcu.west) in
      [draw=black,thick,->] (cu.east) -- (\x2,\y1);
    \path[draw=black,thick,->] (cu) -- (mem);
    \path
      let \p1=(mem.east), \p2=(tcu.west) in
      [draw=black,thick,<-] (mem.east) -- (\x2,\y1);
  \end{tikzpicture}
  \caption{Overview of the TCU's registers and its connections to other components.}
  \label{fig:overview}
\end{figure}

As shown in \rref{fig:overview}, the compute unit~(CU) is connected to the data transfer unit~(TCU)
and can access the TCU's registers via memory mapped input/output (MMIO). Additionally, the CU is
connected to the local memory. The TCU is also connected to the local memory to, for example, access
messages. These components are not necessarily arranged in this way. For example, the TCU might
interpose itself between the CU and local memory.

\section{MMIO region}

The memory interface from CU to TCU is expected to be 64-bit wide. The MMIO region of the TCU is
defined as follows:

\vspace{2ex}
\noindent
\begin{tabular}{ p{3cm} | c | c | l }
  \textbf{Address} & \textbf{Register} & \textbf{Group} & \textbf{Description} \\
  \texttt{0xF000\_0000} & \texttt{FEATURES} & ExtRegs & Contains feature flags \\
  \hline
  \texttt{0xF000\_0008} & \texttt{EXT\_CMD} & ExtRegs & Triggers external commands \\
  \hline
  \texttt{0xF000\_0010} & \texttt{COMMAND} & UnprivRegs & Triggers internal commands \\
  \hline
  \texttt{0xF000\_0018} & \texttt{DATA} & UnprivRegs & Specifies the data for commands \\
  \hline
  \texttt{0xF000\_0020} & \texttt{ARG$_1$} & UnprivRegs & Additional argument for commands \\
  \hline
  \texttt{0xF000\_0028} & \texttt{CUR\_TIME} & UnprivRegs & Yields the current time in nanoseconds \\
  \hline
  \texttt{0xF000\_0030} & \texttt{EP$_{00}$} & EpRegs & First register of EP$_0$ \\
  \texttt{0xF000\_0038} & \texttt{EP$_{01}$} & EpRegs & Second register of EP$_0$ \\
  \texttt{0xF000\_0040} & \texttt{EP$_{02}$} & EpRegs & Third register of EP$_0$ \\
  \hline
  \texttt{0xF000\_0048} & \texttt{EP$_{10}$} & EpRegs & First register of EP$_1$ \\
  \texttt{0xF000\_0050} & \texttt{EP$_{11}$} & EpRegs & Second register of EP$_1$ \\
  \texttt{0xF000\_0058} & \texttt{EP$_{12}$} & EpRegs & Third register of EP$_1$ \\
  \hline
  \multicolumn{4}{c}{\dots} \\
  \hline
  \texttt{0xF000\_0100} & \texttt{EP$_{n0}$} & EpRegs & First register of EP$_{n}$ \\
  \texttt{0xF000\_0108} & \texttt{EP$_{n1}$} & EpRegs & Second register of EP$_{n}$ \\
  \texttt{0xF000\_0110} & \texttt{EP$_{n2}$} & EpRegs & Third register of EP$_{n}$ \\
\end{tabular}

\section{Endpoints}

The TCU has a number of \emph{endpoints}~(EPs) to establish communication channels, which can be
configured to three different EP types: \emph{send EPs} and \emph{receive EPs} are used for message
passing, whereas \emph{memory EPs} are used for RDMA-like memory access. Each EP is represented by a
TCU register and can be configured (at runtime) to one of these EP types. Each EP consists of 192
bits, starting with 3 bits for the endpoint type (T), 16 bits that are reserved for now and
173 bits (shown as dark grey below), whose meaning depends on the EP type:\\[.1em]

\begin{register}{H}{Endpoint}{}
  \regfieldb[gray!60]{}{64}{0}\regnewline%
  \regfieldb[gray!60]{}{64}{0}\regnewline%
  \regfieldb[gray!60]{}{45}{19}%
  \regfieldb[gray!20]{reserved}{16}{3}%
  \regfieldb{type}{3}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[type] the endpoint type: INVALID (0), SEND (1), RECEIVE (2), or MEMORY (3)
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{Memory EP}{}
  \regfieldb{size}{64}{0}\regnewline%
  \regfieldb{addr}{64}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{33}{31}%
  \regfieldb{pe}{8}{23}%
  \regfieldb{rw}{4}{19}%
  \regfieldb[gray!20]{reserved}{16}{3}%
  \regfieldb{type}{3}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[size] the size of the region at the destination
    \item[addr] the base address of the region at the destination
    \item[pe] the destination PE ID
    \item[rw] the permission bits (read = 1, write = 2)
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{Send EP}{}
  \regfieldb{label}{64}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{40}{24}%
  \regfieldb{pe}{8}{16}%
  \regfieldb{ep}{16}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{10}{54}%
  \regfieldb{reply}{1}{53}%
  \regfieldb{crd\_ep}{16}{37}%
  \regfieldb{msg\_sz}{6}{31}%
  \regfieldb{max\_crd}{6}{25}%
  \regfieldb{cur\_crd}{6}{19}%
  \regfieldb[gray!20]{reserved}{16}{3}%
  \regfieldb{type}{3}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[label] the label the TCU puts into the header of each sent message
    \item[pe] the ID of the destination PE
    \item[ep] the ID of the receive EP
    \item[reply] whether this is a reply EP
    \item[crd\_ep] for reply EPs: the send EP at sender-side to receive credits
    \item[max\_crd] the initially received (=max) credits (in messages)
    \item[cur\_crd] the currently owned credits (in messages)
    \item[msg\_sz] the maximum message size supported by the receiver (as power of 2)
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{Receive EP}{}
  \regfieldb{unread}{32}{32}%
  \regfieldb{occupied}{32}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{32}{32}%
  \regfieldb{buffer}{32}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{5}{59}%
  \regfieldb{rpos}{6}{53}%
  \regfieldb{wpos}{6}{47}%
  \regfieldb{slot\_size}{6}{41}%
  \regfieldb{slots}{6}{35}%
  \regfieldb{rpl\_eps}{16}{19}%
  \regfieldb[gray!20]{reserved}{16}{3}%
  \regfieldb{type}{3}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[unread] a bitmask with the unread (not yet fetched) messages in the buffer
    \item[occupied] a bitmask with the occupied slots in the buffer
    \item[buffer] the address of the receive buffer in local memory, must be 8-byte aligned
    \item[rpos] the read position (for message fetches) within the receive buffer
    \item[wpos] the write position (for message receptions) within the receive buffer
    \item[slot\_size] the size of one slot as a power of 2
    \item[slots] the number of slots in the receive buffer as a power of 2
    \item[rpl\_eps] the offset of the reply EPs
  \end{reglist}\end{regdesc}
\end{register}

\section{Commands}

The CU can use the TCU's endpoints via \emph{internal commands}. The unprivileged registers are used
to pass input arguments for a command to the TCU, start a command, and wait until the command is
finished. The following unprivileged registers are used:

\begin{register}{H}{COMMAND}{\texttt{0xF000\_0020}}
  \regfieldb[gray!20]{reserved}{7}{57}%
  \regfieldb{arg0}{32}{25}%
  \regfieldb{error}{4}{21}%
  \regfieldb[gray!20]{reserved}{1}{20}%
  \regfieldb{ep}{16}{4}%
  \regfieldb{op}{4}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[arg0] the first argument for the command
    \item[error] the error code (0 = no error)
    \item[ep] the endpoint to use for the command
    \item[op] the opcode of the command
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{DATA}{\texttt{0xF000\_0028}}
  \regfieldb{size}{32}{32}%
  \regfieldb{address}{32}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[size] the size of the data in local memory
    \item[address] the address of the data in local memory
  \end{reglist}\end{regdesc}
\end{register}

\noindent A write to the \texttt{COMMAND} register starts the command with opcode
\texttt{COMMAND.op}. The meaning of the three argument registers depends on the opcode.

\subsection{Pseudo Code Building Blocks}

The following sections use pseudo code to describe the behavior of the TCU commands, based on
several building blocks:

\begin{itemize}
  \item \texttt{read\_ep(id) -> EP}:\\
  read the TCU-internal EP register with the given id
  \item \texttt{write\_ep(id, EP)}:\\
  write \texttt{EP} to the TCU-internal EP register with given id
  \item \texttt{read\_mem(addr, size) -> data}:\\
  read \texttt{size} bytes from given address in local memory into \texttt{data}
  \item \texttt{write\_mem(data, addr, size)}:\\
  write \texttt{data} of \texttt{size} bytes to given address in local memory
  \item \texttt{read\_remote(pe, size, offset) -> data}:\\
  read \texttt{size} bytes from the given PE at given offset into \texttt{data}
  \item \texttt{write\_remote(data, pe, offset)}:\\
  write \texttt{data} to \texttt{offset} in the given PE
  \item \texttt{send\_msg(msg, pe, ep)}:\\
  send \texttt{msg} to endpoint \texttt{ep} at given PE
  \item \texttt{send\_ack(error)}:\\
  send ACK to the sending TCU and report given error back
  \item \texttt{wait\_for\_ack()}:\\
  wait for the ACK the receiving TCU sends upon successfully storing the message into the receive
  buffer or an error occurred
  \item \texttt{find\_slot(mask, pos, slots, val) -> idx}:\\
  searches for a bit with value \texttt{val} in the given mask between bit 0 and bit $(1 << slots) -
  1$, starting at \texttt{pos} and rotating around. The function returns the position of the bit or
  $-1$ if none was found.
  \item \texttt{exit(error)}:\\
  stop the execution of the command, set \texttt{COMMAND.op} to 0 and \texttt{COMMAND.err} to given error
\end{itemize}

\subsection{Memory Access}

Memory access is performed with a memory EP based on the commands \texttt{READ} and \texttt{WRITE}. The commands behave as follows:

\subsubsection{\texttt{READ}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != MEMORY}{exit(INV\_EP)}
    \uIf{ep.rw \& READ == 0}{exit(NO\_PERM)}
    \uIf{DATA.size + $ARG_1$ > ep.size}{exit(INV\_ARGS)}
    \BlankLine
    $data \gets read\_remote(ep.PE, DATA.size, ep.addr + ARG_1)$\;
    $write\_mem(data, DATA.address, DATA.size)$\;
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{READ} command.}
\end{algorithm}

\subsubsection{\texttt{WRITE}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != MEMORY}{exit(INV\_EP)}
    \uIf{ep.rw \& WRITE == 0}{exit(NO\_PERM)}
    \uIf{DATA.size + $ARG_1$ > ep.size}{exit(INV\_ARGS)}
    \BlankLine
    $data \gets read\_mem(DATA.address, DATA.size)$\;
    $write\_remote(data, ep.PE, ep.addr + ARG_1)$\;
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{WRITE} command.}
\end{algorithm}

\subsection{Message Passing}

Message passing is performed between a send EP and a receive EP. Each send EP is connected to
exactly one receive EP, whereas each receive EP can receive from multiple send EPs. The send EP
supports the command \texttt{SEND}, whereas the receive EP supports \texttt{REPLY}, \texttt{FETCH},
and \texttt{ACK\_MSG}.

Each message consists of a header and a payload. The header is built by the TCU and the payload is
given by the application. The TCU stores both header and payload into the receive buffer in memory.
The header is defined as:

\begin{register}{H}{Message Header}{}
  \regfieldb{label}{32}{32}%
  \regfieldb{rlabel}{32}{0}\regnewline%
  \regfieldb{length}{16}{48}%
  \regfieldb{rep}{16}{32}%
  \regfieldb{sep}{16}{16}%
  \regfieldb{spe}{8}{8}%
  \regfieldb{rsize}{6}{2}%
  \regfieldb{flags}{2}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[label] the label of the sender
    \item[rlabel] the label the receiver should use for the reply
    \item[length] the payload size in bytes
    \item[rep] the receive endpoint ID for the reply at the sender side
    \item[sep] the sender endpoint ID
    \item[spe] the sender PE ID
    \item[rsize] the size of the reply message as a power of 2
    \item[flags] contains the following flags:
    \begin{itemize}
      \item \texttt{REPLY} (1): the message is a reply
    \end{itemize}
  \end{reglist}\end{regdesc}
\end{register}

\noindent The commands and the message reception behave as follows:

\subsubsection{\texttt{SEND}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != SEND or ep.reply != 0}{exit(INV\_EP)}
    \uIf{DATA.size + sizeof(header) > ($1 << ep.msg\_sz$)}{exit(INV\_ARGS)}
    \BlankLine
    \uIf{COMMAND.arg\_0 != 0xFFFF}{
      $rep \gets read\_ep(COMMAND.arg_0$)\;
      \uIf{rep.type != RECEIVE}{exit(INV\_EP)}
      $rsize \gets rep.slot\_size$\;
    }
    \uElse{
      $rep \gets 0xFFFF$\;
      $rsize \gets log2(sizeof(header))$\;
    }
    \BlankLine
    \uIf{ep.cur\_crd != 0x3F}{
    	\uIf{ep.cur\_crd == 0}{exit(MISS\_CREDITS)}
    	ep.cur\_crd -= 1\;
    	$write\_ep(COMMAND.ep, ep)$\;
    	$sep \gets COMMAND.ep$\;
    }
    \uElse{
    	$sep \gets 0xFFFF$\;
    }
    \BlankLine
    $header \gets$ \{ flags $\gets$ 0\;
    $\quad\quad\quad\quad\quad label \gets ep.label$\;
    $\quad\quad\quad\quad\quad length \gets DATA.size$\;
    $\quad\quad\quad\quad\quad rsize \gets rsize$\;
    $\quad\quad\quad\quad\quad rlabel \gets ARG_1$\;
    $\quad\quad\quad\quad\quad spe \gets ownPE$\;
    $\quad\quad\quad\quad\quad sep \gets sep$\;
    $\quad\quad\quad\quad\quad rep \gets rep$ \}\;
    $payload \gets read\_mem(DATA.address, DATA.size)$\;
    $send\_msg(header\ |\ payload, ep.pe, ep.ep)$\;
    $wait\_for\_ack()$\;
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{SEND} command.}
\end{algorithm}

\subsubsection{\texttt{RECEIVE}}

\begin{algorithm}[H]
    \uIf{rep != 0xFFFF}{
      $ep \gets$ read\_ep(rep)\;
      \uIf{ep.type != RECEIVE}{exit(send\_ack(NO\_RING\_SPACE) and drop message)}
      \uIf{(ep.buffer \& 0x7) != 0}{exit(send\_ack(INV\_EP) and drop message)}
      \BlankLine
      $idx \gets$ find\_slot(ep.occupied, ep.wpos, ep.slots, 0)\;
      \uIf{idx == -1}{exit(send\_ack(NO\_RING\_SPACE) and drop message)}
      $ep.occupied.set\_bit(idx)$\;
      $ep.wpos \gets idx + 1$\;
      \BlankLine
      $dest \gets ep.buffer + (idx << ep.slot\_size)$\;
      $write\_mem(header\ |\ payload, dest, sizeof(header) + header.length)$\;
      $ep.unread.set\_bit(idx)$\;
      $write\_ep(rep, ep)$\;
      \BlankLine
      \uIf{(header.flags \& REPLY) == 0 and ep.rpl\_eps != 0xFFFF}{
        $sep \gets \{\ type \gets SEND$\;
        $\quad\quad\quad\ \ \  reply \gets 1$\;
        $\quad\quad\quad\ \ \  pe \gets header.spe$\;
        $\quad\quad\quad\ \ \  ep \gets header.rep$\;
        $\quad\quad\quad\ \ \  label \gets header.rlabel$\;
        $\quad\quad\quad\ \ \  msg\_sz \gets header.rsize$\;
        $\quad\quad\quad\ \ \  max\_crd \gets 1$\;
        $\quad\quad\quad\ \ \  cur\_crd \gets 1$\;
        $\quad\quad\quad\ \ \  crd\_ep \gets header.sep$\ \}\;
        $write\_ep(ep.rpl\_eps + idx, sep)$\;
      }
    }
    \BlankLine
    \uIf{(header.flags \& REPLY) != 0 and header.rep != 0xFFFF}{
      $sep \gets read\_ep(header.rep)$\;
      sep.cur\_crd += 1\;
      $write\_ep(header.rep, sep)$\;
    }
    $send\_ack(NONE)$\;
    \caption{If `header | payload' is received via EP `rep'.}
\end{algorithm}

\subsubsection{\texttt{REPLY}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != RECEIVE or ep.rpl\_eps == 0xFFFF}{exit(INV\_EP)}
    \BlankLine
    $idx \gets (COMMAND.arg_0 - ep.buffer) >> ep.slot\_size$\;
    $sep = read\_ep(ep.rpl\_eps + idx)$\;
    \uIf{sep.type != SEND or sep.reply == 0}{exit(INV\_ARGS)}
    \uIf{DATA.size + sizeof(header) > ($1 << sep.msg\_sz$)}{exit(INV\_ARGS)}
    \uIf{sep.cur\_crd == 0}{exit(MISS\_CREDITS)}
    \BlankLine
    sep.cur\_crd -= 1\;
    $write\_ep(ep.rpl\_eps + idx, sep)$\;
    \BlankLine
    $header \gets$ \{ flags $\gets$ REPLY\;
    $\quad\quad\quad\quad\quad label \gets sep.label$\;
    $\quad\quad\quad\quad\quad length \gets DATA.size$\;
    $\quad\quad\quad\quad\quad rsize \gets 0$\;
    $\quad\quad\quad\quad\quad rlabel \gets 0$\;
    $\quad\quad\quad\quad\quad spe \gets ownPE$\;
    $\quad\quad\quad\quad\quad sep \gets COMMAND.ep$\;
    $\quad\quad\quad\quad\quad rep \gets sep.crd\_ep$ \}\;
    $payload \gets read\_mem(DATA.address, DATA.size)$\;
    $send\_msg(header\ |\ payload, sep.pe, sep.ep)$\;
    $wait\_for\_ack()$\;
    \BlankLine
    $ep.occupied.clear\_bit(idx)$\;
    $ep.unread.clear\_bit(idx)$\;
    $write\_ep(COMMAND.ep, ep)$\;
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{REPLY} command.}
\end{algorithm}

\subsubsection{\texttt{FETCH}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != RECEIVE}{exit(INV\_EP)}
    \uIf{ep.unread == 0}{
      $ARG_1 \gets 0$\;
      exit(0)\;
    }
    \BlankLine
    $idx \gets$ find\_slot(ep.unread, ep.rpos, ep.slots, 1)\;
    $ep.unread.clear\_bit(idx)$\;
    $ep.rpos \gets idx + 1$\;
    $write\_ep(COMMAND.ep, ep)$\;
    \BlankLine
    $ARG_1 \gets ep.buffer + (idx << ep.slot\_size)$\;
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{FETCH} command.}
\end{algorithm}

\subsubsection{\texttt{ACK\_MSG}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != RECEIVE}{exit(INV\_EP)}
    \BlankLine
    $idx \gets (COMMAND.arg_0 - ep.buffer) >> ep.slot\_size$\;
    $ep.occupied.clear\_bit(idx)$\;
    $ep.unread.clear\_bit(idx)$\;
    $write\_ep(COMMAND.ep, ep)$\;
    \BlankLine
    \uIf{ep.rpl\_eps != 0xFFFF}{
      $sep \gets \{~type \gets INVALID~\}$\;
      $write\_ep(ep.rpl\_eps + idx, sep)$\;
    }
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{ACK\_MSG} command.}
\end{algorithm}

\end{document}
