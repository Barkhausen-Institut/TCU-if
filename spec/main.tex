% option draft um zu lange Zeilen anzuzeigen
\documentclass[a4paper,11pt]{book}

\usepackage[inner=3cm,outer=3cm]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
% linux libertine for normal text
\usepackage{libertine}
\usepackage{libertinust1math}
% inconsolate as teletype font
\usepackage{inconsolata}
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathastext}
\usepackage{subcaption}
\usepackage{pmboxdraw}
\usepackage{lipsum}
\usepackage[export]{adjustbox}
\usepackage{csquotes}
\usepackage{tabularx}
\usepackage[sort]{natbib}
\usepackage[toc,nonumberlist]{glossaries}
\usepackage{makecell}
\usepackage[absolute,overlay]{textpos}
\usepackage{microtype}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage[color]{register}
\usepackage[leftbars,color]{changebar}

\colorlet{pemux}{green!20}
\cbcolor{pemux}
\setlength{\changebarwidth}{.4em}

\renewcommand{\regBitWidth}{64}
\setlength{\regWidth}{\textwidth}

% setup of siunitx
\usepackage[binary-units=true]{siunitx}
\DeclareSIUnit{\bits}{bits}
\DeclareSIUnit{\cycle}{cycle}
\DeclareSIUnit{\cycles}{cycles}
\sisetup{
  list-final-separator = {, and },
  per-mode=symbol
}

% tikz
\usepackage{tikz}
\usepackage{tikz-uml}
\usetikzlibrary{arrows,automata,positioning}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{calc}
\usetikzlibrary{intersections}
\usetikzlibrary{patterns}

% tikz setup
\usepackage{environ}
\makeatletter
\newsavebox{\measure@tikzpicture}
\NewEnviron{scaletikzpicturetowidth}[1]{%
  \def\tikz@width{#1}%
  \def\tikzscale{1}\begin{lrbox}{\measure@tikzpicture}%
  \BODY
  \end{lrbox}%
  \pgfmathparse{#1/\wd\measure@tikzpicture}%
  \edef\tikzscale{\pgfmathresult}%
  \BODY
}

\makeatother
\tikzstyle{thick arrow}=[-{Latex[length=2mm]}]

% hyperlinks
\usepackage{hyperref}
\hypersetup{
  pdfauthor   = {Nils Asmussen},
  pdftitle    = {TCU Specification},
  pdfborder   = {0 0 0 [0 0]},
  colorlinks  = false
}

% listings
\usepackage{listings}
\lstset{basicstyle=\small\ttfamily,breaklines=true}
\lstdefinestyle{myc++}{
  language=C++,
  morekeywords={size_t,ssize_t}
}

% ignore page group warnings
\pdfsuppresswarningpagegroup=1

% redefine some names
\addto\extrasenglish{%
  \renewcommand{\chapterautorefname}{Chapter}%
  \renewcommand{\sectionautorefname}{Section}%
  \renewcommand{\subsectionautorefname}{Section}%
  \renewcommand{\subsubsectionautorefname}{Section}%
}

% for smart references
\newcommand{\rref}[2][]{\autoref{#2}}

% names
\newcommand{\myos}{$\text{M}^\mathbf{3}$}
\newcommand{\myfs}{$\text{M}^\mathbf{3}$FS}

% TODOs
\newcommand{\todo}[1]{\fbox{\bfseries\sffamily\scriptsize\color{red}TODO: #1}}

\title{Trusted Communication Unit -- Specification}
\author{Nils Asmussen}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\chapter{System Overview}
\label{sec:systemoverview}

\newcommand{\fillpe}[3]{
    \node[below=.6em of #1.north] {#2};
    \node[cu, above right=.6em and .6em of #1.south west,#3] (cu1) {CU};
    \node[tcu,above left=.6em and .6em of #1.south east,#3] (tcu1) {TCU};

    \draw[noc] ($(#1.south west)-(0,1.0em)$) -- ($(pe3.south east)-(0,1.0em)$);
    \draw[noc] ($(#1.south west)-(0,1.2em)$) -- ($(pe3.south east)-(0,1.2em)$);
    \draw[noc] ($(#1.south west)-(0,1.4em)$) -- ($(pe3.south east)-(0,1.4em)$);

    \draw
      let \p1=(tcu1.south), \p2=($(#1.south west)-(0,1.2em)$) in
      (tcu1.south) -- (\x1, \y2);
    \fill[radius=.2em]
      let \p1=(tcu1.south), \p2=($(#1.south west)-(0,1.2em)$) in
      (\x1, \y2) circle node {};
}

\begin{figure}[h]
  \center
  \begin{tikzpicture}[
      pe/.style={draw=gray,minimum width=9.5em,minimum height=8em},
      cu/.style={draw=gray,fill=red!50,minimum width=4.5em,minimum height=4.5em},
      tcu/.style={draw=gray,fill=green!50,minimum width=3em,minimum height=3em},
      noc/.style={draw=green},
    ]

    \node[pe] (pe1) {};
    \node[pe,right=2em of pe1] (pe2) {};
    \node[pe,right=2em of pe2] (pe3) {};

    \fillpe{pe1}{Kernel PE}{fill=green!50};
    \fillpe{pe2}{User PE}{};
    \fillpe{pe3}{User PE}{};

  \end{tikzpicture}
  \caption{System Overview.}
  \label{fig:sysoverview}
\end{figure}

\noindent The trusted communication unit~(TCU) is a building block that can be used to construct
secure systems. As shown in \rref{fig:sysoverview}, the system consists of multiple processing
elements~(PEs), each containing a compute unit~(CU) and a TCU. The PEs are linked through some
interconnect (e.g., a network-on-chip) and are split into \emph{kernel PEs} and \emph{user PEs}. The
former are privileged (green) and manage the TCUs of the user PEs, whereas the latter are
unprivileged (red).

In this system, the TCU, the interconnect, and the kernel PEs are trusted (shown green), whereas the
CUs in the user PEs are untrusted (shown red). By default, all PEs are isolated from each other, but
communication channels between PEs can be established. These communication channels can only kernel
be establish by kernel PEs, but can be used afterwards by user PEs.

Privilege is defined by the TCU's \texttt{FEATURES} register, which is set to be privileged at boot
and can be downgraded afterwards.

\section{Processing Elements}

\begin{figure}[h]
  \center
  \begin{tikzpicture}[
      tcureg/.style={draw=gray,fill=white,minimum width=2.6cm},
      regtbl/.style={draw=black,fill=gray!30,minimum width=3cm}
    ]

    \node[draw=black,minimum width=7cm,minimum height=7.65cm,anchor=north west] (tcu) at(4,0) {};
    \node[draw=black,minimum width=3.4cm,minimum height=3.2cm,anchor=north west] (cu) at (0,0) {CU};
    \node[draw=black,minimum width=3.4cm,minimum height=3.2cm,anchor=south west] (mem) at (0,-7) {SPM/Cache};

    \node[below right=.1cm and .1cm of tcu.north west] {TCU};

    \node[
      regtbl,below right=.8cm and .2cm of tcu.north west,minimum height=2cm
    ] (tcuregs) {};
    \node[below=.1cm of tcuregs.north] {ExtRegs};
    \node[tcureg,below=.7cm of tcuregs.north] (extreg0) {\texttt{FEATURES}};
    \node[tcureg,below=0cm of extreg0]        (extreg1) {\texttt{EXT\_CMD}};

    \node[
      regtbl,below=1cm of tcuregs.south,minimum height=3cm
    ] (cmdregs) {};
    \node[below=.1cm of cmdregs.north] {UnprivRegs};
    \node[tcureg,below=.7cm of cmdregs.north] (cmdreg0) {\texttt{COMMAND}};
    \node[tcureg,below=0cm of cmdreg0]        (cmdreg1) {\texttt{DATA}};
    \node[tcureg,below=0cm of cmdreg1]        (cmdreg2) {\texttt{ARG$_1$}};
    \node[tcureg,below=0cm of cmdreg2]        (cmdreg3) {\texttt{CUR\_TIME}};

    \node[
      regtbl,below left=1cm and .4cm of tcu.north east,minimum height=2.6cm
    ] {};
    \node[
      regtbl,below left=.9cm and .3cm of tcu.north east,minimum height=2.6cm
    ] {};
    \node[
      regtbl,below left=.8cm and .2cm of tcu.north east,minimum height=2.6cm
    ] (epregs) {};
    \node[below=.1cm of epregs.north] {EpRegs};
    \node[tcureg,below=.7cm of epregs.north] (epreg0) {\texttt{EP$_0$}};
    \node[tcureg,below=0cm of epreg0]        (epreg1) {\texttt{EP$_1$}};
    \node[tcureg,below=0cm of epreg1]        (epreg2) {\texttt{EP$_2$}};

    \node[
      regtbl,fill=pemux,below right=0cm and .38cm of cmdregs.north east,minimum height=3.6cm
    ] (prvregs) {};
    \node[below=.1cm of prvregs.north] {PrivRegs};
    \node[tcureg,below=.7cm of prvregs.north] (prvreg0) {\texttt{CORE\_REQ}};
    \node[tcureg,below=0cm of prvreg0]        (prvreg1) {\texttt{PRIV\_CMD}};
    \node[tcureg,below=0cm of prvreg1]        (prvreg2) {\texttt{PRIV\_CMD\_ARG}};
    \node[tcureg,below=0cm of prvreg2]        (prvreg3) {\texttt{CUR\_VPE}};
    \node[tcureg,below=0cm of prvreg3]        (prvreg4) {\texttt{OLD\_VPE}};

    \path
      let \p1=(cu.east), \p2=(tcu.west) in
      [draw=black,thick,->] (cu.east) -- (\x2,\y1);
    \path[draw=black,thick,->] (cu) -- (mem);
    \path
      let \p1=(mem.east), \p2=(tcu.west) in
      [draw=black,thick,<-] (mem.east) -- (\x2,\y1);
  \end{tikzpicture}
  \caption{The internal organization of a PE.}
  \label{fig:peinternal}
\end{figure}

\rref{fig:peinternal} shows the internals of a processing element~(PE). The compute unit~(CU) is
connected to the data transfer unit~(TCU) and can access the TCU's registers via memory mapped
input/output (MMIO). Additionally, the CU is connected to the local memory. The TCU is also
connected to the local memory to, for example, access messages. These components are not necessarily
arranged in this way. For example, the TCU might interpose itself between the CU and local memory.

To support the security model introduced in \rref{sec:systemoverview}, the registers are split into
different groups, each group having different access permissions. All registers are generally
readable. \emph{External registers} can only be written externally, that is, from a remote PE. They
are intended for the kernel PE to manipulate the state of remote TCUs. \emph{Endpoint registers} can
be written externally and locally by the kernel PE. \emph{Unprivileged registers} can be written by
the CU. In consequence, only kernel PEs can \emph{establish} communication channels by writing
endpoint registers, but user PEs can \emph{use} these communication channels through the
unprivileged registers.

\cbstart The \emph{privileged registers} are intended for privileged software running on PEs that
are shared among multiple VPEs. The privileged software is called \emph{PEMux} for PE multiplexer.
PEMux should make sure that unprivileged software running on the same PE cannot access the
privileged registers. \cbend

\section{Registers}

The TCU has several registers that are accessible through memory-mapped input/output~(MMIO). The
memory interface from CU to TCU is expected to be 64-bit wide. The MMIO region of the TCU is defined
as follows:

\vspace{2ex}
\noindent
\begin{tabular}{ p{3cm} | c | c | l }
  \textbf{Address} & \textbf{Register} & \textbf{Group} & \textbf{Description} \\
  \hline
  \hline
  \texttt{0xF000\_0000} & \texttt{FEATURES} & ExtRegs & Contains feature flags \\
  \hline
  \texttt{0xF000\_0008} & \texttt{EXT\_CMD} & ExtRegs & Triggers external commands \\
  \hline
  \hline
  \texttt{0xF000\_0010} & \texttt{COMMAND} & UnprivRegs & Triggers unprivileged commands \\
  \hline
  \texttt{0xF000\_0018} & \texttt{DATA} & UnprivRegs & Specifies the data for commands \\
  \hline
  \texttt{0xF000\_0020} & \texttt{ARG$_1$} & UnprivRegs & Additional argument for commands \\
  \hline
  \texttt{0xF000\_0028} & \texttt{CUR\_TIME} & UnprivRegs & Yields the current time in nanoseconds \\
  \hline
  \hline
  \texttt{0xF000\_0030} & \texttt{EP$_{00}$} & EpRegs & First register of EP$_0$ \\
  \texttt{0xF000\_0038} & \texttt{EP$_{01}$} & EpRegs & Second register of EP$_0$ \\
  \texttt{0xF000\_0040} & \texttt{EP$_{02}$} & EpRegs & Third register of EP$_0$ \\
  \hline
  \texttt{0xF000\_0048} & \texttt{EP$_{10}$} & EpRegs & First register of EP$_1$ \\
  \texttt{0xF000\_0050} & \texttt{EP$_{11}$} & EpRegs & Second register of EP$_1$ \\
  \texttt{0xF000\_0058} & \texttt{EP$_{12}$} & EpRegs & Third register of EP$_1$ \\
  \hline
  \multicolumn{4}{c}{\dots} \\
  \hline
  \texttt{0xF000\_0100} & \texttt{EP$_{n0}$} & EpRegs & First register of EP$_{n}$ \\
  \texttt{0xF000\_0108} & \texttt{EP$_{n1}$} & EpRegs & Second register of EP$_{n}$ \\
  \texttt{0xF000\_0110} & \texttt{EP$_{n2}$} & EpRegs & Third register of EP$_{n}$ \\
  \hline
  \hline
  \texttt{0xF000\_1000} & \texttt{CORE\_REQ} & PrivRegs & TCU-core interactions \cbstart \\
  \texttt{0xF000\_1008} & \texttt{PRIV\_CMD} & PrivRegs & Triggers privileged commands \\
  \texttt{0xF000\_1010} & \texttt{PRIV\_CMD\_ARG} & PrivRegs & Argument for privileged commands \\
  \texttt{0xF000\_1018} & \texttt{CUR\_VPE} & PrivRegs & Currently running VPE \\
  \texttt{0xF000\_1020} & \texttt{OLD\_VPE} & PrivRegs & Old VPE when changing VPEs \cbend \\
\end{tabular}\\[1em]

\chapter{Endpoints}

The TCU has a number of \emph{endpoints}~(EPs) to establish communication channels, which can be
configured to three different EP types: \emph{send EPs} and \emph{receive EPs} are used for message
passing, whereas \emph{memory EPs} are used for RDMA-like memory access. Each EP is represented by a
TCU register and can be configured (at runtime) to one of these EP types. Each EP consists of 192
bits, starting with 3 bits for the endpoint type (T), 16 bits for the VPE that can use the EP and
173 bits (shown as dark grey below), whose meaning depends on the EP type:\\[.1em]

\begin{register}{H}{Endpoint}{}
  \regfieldb[gray!60]{}{64}{0}\regnewline%
  \regfieldb[gray!60]{}{64}{0}\regnewline%
  \regfieldb[gray!60]{}{45}{19}%
  \regfieldb[pemux]{vpe}{16}{3}%
  \regfieldb{type}{3}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[vpe] \cbstart the id of the VPE that can use this endpoint \cbend
    \item[type] the endpoint type: INVALID (0), SEND (1), RECEIVE (2), or MEMORY (3)
  \end{reglist}\end{regdesc}
\end{register}

\section{Memory Endpoint}

\begin{register}{H}{Memory EP}{}
  \regfieldb{size}{64}{0}\regnewline%
  \regfieldb{addr}{64}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{33}{31}%
  \regfieldb{pe}{8}{23}%
  \regfieldb{rw}{4}{19}%
  \regfieldb[pemux]{vpe}{16}{3}%
  \regfieldb{type}{3}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[size] the size of the region at the destination
    \item[addr] the base address of the region at the destination
    \item[pe] the destination PE ID
    \item[rw] the permission bits (read = 1, write = 2)
  \end{reglist}\end{regdesc}
\end{register}

\section{Send Endpoint}

\begin{register}{H}{Send EP}{}
  \regfieldb[gray!20]{reserved}{32}{32}%
  \regfieldb{label}{32}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{40}{24}%
  \regfieldb{tgt\_pe}{8}{16}%
  \regfieldb{tgt\_ep}{16}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{10}{54}%
  \regfieldb{reply}{1}{53}%
  \regfieldb{crd\_ep}{16}{37}%
  \regfieldb{msg\_sz}{6}{31}%
  \regfieldb{max\_crd}{6}{25}%
  \regfieldb{cur\_crd}{6}{19}%
  \regfieldb[pemux]{vpe}{16}{3}%
  \regfieldb{type}{3}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[label] the label the TCU puts into the header of each sent message
    \item[tgt\_pe] the ID of the target PE
    \item[tgt\_ep] the ID of the receive EP at the target PE
    \item[reply] whether this is a reply EP
    \item[crd\_ep] for reply EPs: the send EP at sender-side to receive credits
    \item[max\_crd] the initially received (=max) credits (in messages)
    \item[cur\_crd] the currently owned credits (in messages)
    \item[msg\_sz] the maximum message size supported by the receiver (as power of 2)
  \end{reglist}\end{regdesc}
\end{register}

\section{Receive Endpoint}

\begin{register}{H}{Receive EP}{}
  \regfieldb{unread}{32}{32}%
  \regfieldb{occupied}{32}{0}\regnewline%
  \regfieldb{buffer}{64}{0}\regnewline%
  \regfieldb[gray!20]{reserved}{5}{59}%
  \regfieldb{rpos}{6}{53}%
  \regfieldb{wpos}{6}{47}%
  \regfieldb{slot\_size}{6}{41}%
  \regfieldb{slots}{6}{35}%
  \regfieldb{rpl\_eps}{16}{19}%
  \regfieldb[pemux]{vpe}{16}{3}%
  \regfieldb{type}{3}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[unread] a bitmask with the unread (not yet fetched) messages in the buffer
    \item[occupied] a bitmask with the occupied slots in the buffer
    \item[buffer] the physical address of the receive buffer, must be 8-byte aligned
    \item[rpos] the read position (for message fetches) within the receive buffer
    \item[wpos] the write position (for message receptions) within the receive buffer
    \item[slot\_size] the size of one slot as a power of 2
    \item[slots] the number of slots in the receive buffer as a power of 2
    \item[rpl\_eps] the offset of the reply EPs
  \end{reglist}\end{regdesc}
\end{register}

\chapter{Transfers}

The TCU uses \emph{transfers} to load data from local memory or write data into local memory. Since
these local memory accesses need to be performed in multiple steps and need to be paused and
resumed\colorbox{pemux}{, under some conditions,} the TCU maintains state for each transfer and
supports a limited number of transfers at a time (at least 2). However, the transfers and their
states are not software facing, so that this specification does not describe any software interface,
but only the behavior of transfers.

There are two different kinds of transfers: \emph{local transfers} issued by \texttt{read\_local()},
\texttt{write\_local()}, or \texttt{write\_local\_phys()} and \emph{remote transfers} issued by
\texttt{read\_remote()} or \texttt{write\_remote()} (see \rref{sec:unprivcmdspseudo}). Local
transfers always belong to the current unprivileged command, implying that there is at most one.
Remote transfers are triggered by requests from other TCUs (e.g., an incoming message or an access
to the local memory).

\cbstart
\section{Translations}

With virtual memory support, all transfers except \texttt{write\_local\_phys()} refer to a virtual
address and thus require address translations to determine the physical address for the actual
memory access. The TCU keeps a small translation look-aside buffer~(TLB) to cache these translations
and issues a translation core request on TLB misses. In this case, the transfer is paused until the
completion of a translation core request, which creates a corresponding new TLB entry and resumes
the transfer.

While both local and remote transfers require address translations, only local transfers can cause
page faults. If a remote transfer triggers a page fault (due to insufficient permissions, either in
TLB or reported by software upon a translation core request), the transfer is aborted with the error
\texttt{PAGEFAULT}. Local transfers can cause page faults, leading to potentially long transfer
times.

Without virtual memory support, there is no difference between \texttt{write\_local()} and
\texttt{write\_local\_phys()}. However, with virtual memory support, \texttt{write\_local\_phys()}
refers to a physical address, so that no translation is required.

\section{Translation Look-aside Buffer}
\label{sec:tlb}

The TLB contains a virtual address, 16-bit address space id~(asid), physical address, and
permissions. The permissions are defined as follows:

\begin{itemize}
  \item \texttt{READ} (1): read permission,
  \item \texttt{WRITE} (2): write permission,
  \item \texttt{EXEC} (4): execute permission \todo{remove that?},
  \item \texttt{LARGE} (8): large page mapping (2 MiB),
  \item \texttt{FIXED} (16): fixed entry, will not be evicted.
\end{itemize}
\cbend

\chapter{Unprivileged Interface}

The unprivileged interface of the TCU is available to unprivileged software. Most importantly, it
allows to use the TCU's endpoints via \emph{unprivileged commands}. The unprivileged registers are
used to pass input arguments for a command to the TCU, start a command, and wait until the command
is finished. The following unprivileged registers are used:

\begin{register}{H}{COMMAND}{\texttt{0xF000\_0010}}
  \regfieldb[gray!20]{reserved}{8}{56}%
  \regfieldb{arg0}{32}{24}%
  \regfieldb{error}{4}{20}%
  \regfieldb{ep}{16}{4}%
  \regfieldb{op}{4}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[arg0] the first argument for the command
    \item[error] the error code (0 = no error)
    \item[ep] the endpoint to use for the command
    \item[op] the opcode of the command
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{DATA}{\texttt{0xF000\_0018}}
  \regfieldb{size}{32}{32}%
  \regfieldb{address}{32}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[size] the size of the data in local memory
    \item[address] the address of the data in local memory
  \end{reglist}\end{regdesc}
\end{register}

\noindent A write to the \texttt{COMMAND} register starts the command with opcode
\texttt{COMMAND.op}. The meaning of the three argument registers depends on the opcode.

\section{Command List}

The TCU supports the following unprivileged commands with the opcodes in parentheses:

\begin{itemize}
  \item \texttt{SEND} (1): send a message via a send EP to a receive EP,
  \item \texttt{REPLY} (2): reply on a message that has been received earlier via a receive EP,
  \item \texttt{READ} (3): read data from a region defined in a memory EP into local memory,
  \item \texttt{WRITE} (4): write data from local memory into a region defined in a memory EP,
  \item \texttt{FETCH} (5): fetch a new message from a receive EP,
  \item \texttt{ACK\_MSG} (6): acknowledge that the processing of a message has been completed.
\end{itemize}

\section{Pseudo Code Building Blocks}
\label{sec:unprivcmdspseudo}

The following sections use pseudo code to describe the behavior of the TCU commands, based on
several building blocks:

\begin{itemize}
  \item \texttt{read\_ep(id) -> EP}:\\
  read the TCU-internal EP register with the given id. If the id is out of bounds, an invalid EP is
  returned.
  \item \texttt{write\_ep(id, EP)}:\\
  write \texttt{EP} to the TCU-internal EP register with given id (assumed to be within bounds)
  \item \texttt{read\_local(virt\_addr, size) -> (Error, data)}:\\
  read \texttt{size} bytes from given address in local memory into \texttt{data} and return the error
  code (0~=~success)
  \item \texttt{write\_local(data, virt\_addr, size) -> Error}:\\
  write \texttt{data} of \texttt{size} bytes to given address in local memory and return the error
  code (0~=~success)
  \item \texttt{write\_local\_phys(data, phys\_addr, size)}:\\
  write \texttt{data} of \texttt{size} bytes to given physical address in local memory
  \item \texttt{read\_remote(pe, size, offset) -> (Error, data)}:\\
  read \texttt{size} bytes from the given PE at given offset into \texttt{data} and return the error
  code (0~=~success)
  \item \texttt{write\_remote(data, pe, offset) -> Error}:\\
  write \texttt{data} to \texttt{offset} in the given PE and return the error code (0~=~success)
  \item \texttt{send\_msg(msg, pe, ep)}:\\
  send \texttt{msg} to endpoint \texttt{ep} at given PE
  \item \texttt{send\_ack(error)}:\\
  send ACK to the sending TCU and report given error back
  \item \texttt{wait\_for\_ack()}:\\
  wait for the ACK the receiving TCU sends upon successfully storing the message into the receive
  buffer or an error occurred
  \item \texttt{find\_slot(mask, pos, slots, val) -> idx}:\\
  searches for a bit with value \texttt{val} in the given mask between bit 0 and bit $(1 << slots) -
  1$, starting at \texttt{pos} and rotating around. The function returns the position of the bit or
  $-1$ if none was found.
  \item \texttt{unpriv\_fail(error)}:\\
  stop the execution of the unprivileged command by setting the opcode in \texttt{COMMAND} to 0 and
  the error code to the given error.
  \item \texttt{queue\_foreign\_msg\_req(ep, vpe)}:\cbstart\\
  append a new foreign-message request to the queue of core requests. \cbend
\end{itemize}

\section{Memory Access}

Memory access is performed with a memory EP based on the commands \texttt{READ} and \texttt{WRITE}.
The commands behave as follows:

\subsection{\texttt{READ}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != MEMORY\colorbox{pemux}{ or ep.vpe != $CUR\_VPE.id$}}{unpriv\_fail(INV\_EP)}
    \uIf{ep.rw \& READ == 0}{unpriv\_fail(NO\_PERM)}
    \uIf{DATA.size + $ARG_1$ > ep.size}{unpriv\_fail(INV\_ARGS)}
    \BlankLine
    $(err, data) \gets read\_remote(ep.PE, DATA.size, ep.addr + ARG_1)$\;
    \uIf{err != 0}{unpriv\_fail(err)}
    \BlankLine
    $err \gets write\_local(data, DATA.address, DATA.size)$\;
    \uIf{err != 0}{unpriv\_fail(err)}
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{READ} command.}
\end{algorithm}

\subsection{\texttt{WRITE}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != MEMORY\colorbox{pemux}{ or ep.vpe != $CUR\_VPE.id$}}{unpriv\_fail(INV\_EP)}
    \uIf{ep.rw \& WRITE == 0}{unpriv\_fail(NO\_PERM)}
    \uIf{DATA.size + $ARG_1$ > ep.size}{unpriv\_fail(INV\_ARGS)}
    \BlankLine
    $(err, data) \gets read\_local(DATA.address, DATA.size)$\;
    \uIf{err != 0}{unpriv\_fail(err)}
    $err \gets write\_remote(data, ep.PE, ep.addr + ARG_1)$\;
    \uIf{err != 0}{unpriv\_fail(err)}
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{WRITE} command.}
\end{algorithm}

\section{Message Passing}

Message passing is performed between a send EP and a receive EP. Each send EP is connected to
exactly one receive EP, whereas each receive EP can receive from multiple send EPs. The send EP
supports the command \texttt{SEND}, whereas the receive EP supports \texttt{REPLY}, \texttt{FETCH},
and \texttt{ACK\_MSG}.

For flow control and to prevent denial-of-service attacks on recipients, the TCU uses a credit
system. The idea is to let the recipient hand out credits to its senders, decrease the credits on
sent messages and increase them again on received replies.

Each message consists of a header and a payload. The header is built by the TCU and the payload is
given by the application. The TCU stores both header and payload into the receive buffer in memory.
The header is defined as:

\begin{register}{H}{Message Header}{}
  \regfieldb{label}{32}{32}%
  \regfieldb{rlabel}{32}{0}\regnewline%
  \regfieldb{length}{16}{48}%
  \regfieldb{rep}{16}{32}%
  \regfieldb{sep}{16}{16}%
  \regfieldb{spe}{8}{8}%
  \regfieldb{rsize}{6}{2}%
  \regfieldb{flags}{2}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[label] the label of the sender
    \item[rlabel] the label the receiver should use for the reply
    \item[length] the payload size in bytes
    \item[rep] the receive endpoint ID for the reply at the sender side
    \item[sep] the sender endpoint ID
    \item[spe] the sender PE ID
    \item[rsize] the size of the reply message as a power of 2
    \item[flags] contains the following flags:
    \begin{itemize}
      \item \texttt{REPLY} (1): the message is a reply
    \end{itemize}
  \end{reglist}\end{regdesc}
\end{register}

\noindent The commands and the message reception behave as follows:

\subsection{\texttt{SEND}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != SEND or ep.reply != 0\colorbox{pemux}{ or ep.vpe != $CUR\_VPE.id$}}{unpriv\_fail(INV\_EP)}
    \uIf{DATA.size + sizeof(header) > ($1 << ep.msg\_sz$)}{unpriv\_fail(INV\_ARGS)}
    \BlankLine
    \uIf{COMMAND.arg\_0 != 0xFFFF}{
      $rep \gets read\_ep(COMMAND.arg_0$)\;
      \uIf{rep.type != RECEIVE}{unpriv\_fail(INV\_EP)}
      $repid \gets COMMAND.arg_0$\;
      $rsize \gets rep.slot\_size$\;
    }
    \uElse{
      $repid \gets 0xFFFF$\;
      $rsize \gets log2(sizeof(header))$\;
    }
    \BlankLine
    $(err, payload) \gets read\_local(DATA.address, DATA.size)$\;
    \uIf{err != 0}{unpriv\_fail(err)}
    \BlankLine
    \uIf{ep.cur\_crd != 0x3F}{
    	\uIf{ep.cur\_crd == 0}{unpriv\_fail(MISS\_CREDITS)}
    	ep.cur\_crd -= 1\;
    	$write\_ep(COMMAND.ep, ep)$\;
    	$sepid \gets COMMAND.ep$\;
    }
    \uElse{
    	$sepid \gets 0xFFFF$\;
    }
    \BlankLine
    $header \gets$ \{ flags $\gets$ 0\;
    $\quad\quad\quad\quad\quad label \gets ep.label$\;
    $\quad\quad\quad\quad\quad length \gets DATA.size$\;
    $\quad\quad\quad\quad\quad rsize \gets rsize$\;
    $\quad\quad\quad\quad\quad rlabel \gets ARG_1$\;
    $\quad\quad\quad\quad\quad spe \gets ownPE$\;
    $\quad\quad\quad\quad\quad sep \gets sepid$\;
    $\quad\quad\quad\quad\quad rep \gets repid$ \}\;
    $send\_msg(header\ |\ payload, ep.tgt\_pe, ep.tgt\_ep)$\;
    $wait\_for\_ack()$\;
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{SEND} command.}
\end{algorithm}

\subsection{\texttt{RECEIVE}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(rep)\;
    \uIf{ep.type != RECEIVE or (ep.buffer \& 0x7) != 0}{unpriv\_fail(send\_ack(INV\_EP) and drop message)}
    \BlankLine
    $idx \gets$ find\_slot(ep.occupied, ep.wpos, ep.slots, 0)\;
    \uIf{idx == -1}{unpriv\_fail(send\_ack(NO\_RING\_SPACE) and drop message)}
    $ep.occupied.set\_bit(idx)$\;
    $ep.wpos \gets idx + 1$\;
    \BlankLine
    $dest \gets ep.buffer + (idx << ep.slot\_size)$\;
    $write\_local\_phys(header\ |\ payload, dest, sizeof(header) + header.length)$\;
    $ep.unread.set\_bit(idx)$\;
    $write\_ep(rep, ep)$\;
    \BlankLine
    \uIf{(header.flags \& REPLY) == 0 and ep.rpl\_eps != 0xFFFF and header.rep != 0xFFFF}{
      $sep \gets \{\ type \gets SEND$\;
      $\quad\quad\quad\ \ \  reply \gets 1$\;
      $\quad\quad\quad\ \ \  tgt\_pe \gets header.spe$\;
      $\quad\quad\quad\ \ \  tgt\_ep \gets header.rep$\;
      $\quad\quad\quad\ \ \  label \gets header.rlabel$\;
      $\quad\quad\quad\ \ \  msg\_sz \gets header.rsize$\;
      $\quad\quad\quad\ \ \  max\_crd \gets 1$\;
      $\quad\quad\quad\ \ \  cur\_crd \gets 1$\;
      $\quad\quad\quad\ \ \  crd\_ep \gets header.sep$\ \}\;
      $write\_ep(ep.rpl\_eps + idx, sep)$\;
    }
    \BlankLine
    \uIf{(header.flags \& REPLY) != 0 and header.rep != 0xFFFF}{
      $sep \gets read\_ep(header.rep)$\;
      sep.cur\_crd += 1\;
      $write\_ep(header.rep, sep)$\;
    }
    $send\_ack(NONE)$\;
    \cbstart
    \BlankLine
    \uIf{ep.vpe == CUR\_VPE.id}{
      CUR\_VPE.msgs += 1\;
    }
    \uElse{
      $queue\_foreign\_msg\_req(rep, ep.vpe)$\;
    }
    \cbend
    \caption{If `header | payload' is received via EP `rep'.}
\end{algorithm}

\subsection{\texttt{REPLY}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != RECEIVE or ep.rpl\_eps == 0xFFFF\colorbox{pemux}{ or ep.vpe != $CUR\_VPE.id$}}{unpriv\_fail(INV\_EP)}
    \BlankLine
    $idx \gets COMMAND.arg_0 >> ep.slot\_size$\;
    $sep = read\_ep(ep.rpl\_eps + idx)$\;
    \uIf{sep.type != SEND or sep.reply == 0}{unpriv\_fail(INV\_ARGS)}
    \uIf{DATA.size + sizeof(header) > ($1 << sep.msg\_sz$)}{unpriv\_fail(INV\_ARGS)}
    \BlankLine
    $(err, payload) \gets read\_local(DATA.address, DATA.size)$\;
    \uIf{err != 0}{unpriv\_fail(err)}
    \BlankLine
    \uIf{sep.cur\_crd == 0}{unpriv\_fail(MISS\_CREDITS)}
    sep.cur\_crd -= 1\;
    $write\_ep(ep.rpl\_eps + idx, sep)$\;
    \BlankLine
    $header \gets$ \{ flags $\gets$ REPLY\;
    $\quad\quad\quad\quad\quad label \gets sep.label$\;
    $\quad\quad\quad\quad\quad length \gets DATA.size$\;
    $\quad\quad\quad\quad\quad rsize \gets 0$\;
    $\quad\quad\quad\quad\quad rlabel \gets 0$\;
    $\quad\quad\quad\quad\quad spe \gets ownPE$\;
    $\quad\quad\quad\quad\quad sep \gets COMMAND.ep$\;
    $\quad\quad\quad\quad\quad rep \gets sep.crd\_ep$ \}\;
    $send\_msg(header\ |\ payload, sep.tgt\_pe, sep.tgt\_ep)$\;
    $wait\_for\_ack()$\;
    \BlankLine
    \cbstart
    \uIf{ep.unread.is\_set(idx)}{
      CUR\_VPE.msgs -= 1\;
    }
    \cbend
    \BlankLine
    $ep.occupied.clear\_bit(idx)$\;
    $ep.unread.clear\_bit(idx)$\;
    $write\_ep(COMMAND.ep, ep)$\;
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{REPLY} command.}
\end{algorithm}

\subsection{\texttt{FETCH}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != RECEIVE\colorbox{pemux}{ or ep.vpe != $CUR\_VPE.id$}}{unpriv\_fail(INV\_EP)}
    \uIf{ep.unread == 0\colorbox{pemux}{ or CUR\_VPE.msgs == 0}}{
      $ARG_1 \gets -1$\;
      unpriv\_fail(0)\;
    }
    \BlankLine
    $idx \gets$ find\_slot(ep.unread, ep.rpos, ep.slots, 1)\;
    $ep.unread.clear\_bit(idx)$\;
    $ep.rpos \gets idx + 1$\;
    $write\_ep(COMMAND.ep, ep)$\;
    \BlankLine
    \cbstart
    CUR\_VPE.msgs -= 1\;
    \cbend
    \BlankLine
    $ARG_1 \gets idx << ep.slot\_size$\;
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{FETCH} command.}
\end{algorithm}

\subsection{\texttt{ACK\_MSG}}

\begin{algorithm}[H]
    $ep \gets$ read\_ep(COMMAND.ep)\;
    \uIf{ep.type != RECEIVE\colorbox{pemux}{ or ep.vpe != $CUR\_VPE.id$}}{unpriv\_fail(INV\_EP)}
    \BlankLine
    $idx \gets COMMAND.arg_0 >> ep.slot\_size$\;
    \BlankLine
    \cbstart
    \uIf{ep.unread.is\_set(idx)}{
      CUR\_VPE.msgs -= 1\;
    }
    \cbend
    \BlankLine
    $ep.occupied.clear\_bit(idx)$\;
    $ep.unread.clear\_bit(idx)$\;
    $write\_ep(COMMAND.ep, ep)$\;
    \BlankLine
    \uIf{ep.rpl\_eps != 0xFFFF}{
      $sep \gets \{~type \gets INVALID~\}$\;
      $write\_ep(ep.rpl\_eps + idx, sep)$\;
    }
    \BlankLine
    $COMMAND \gets 0$\;
    \caption{The TCU's \texttt{ACK\_MSG} command.}
\end{algorithm}

\cbstart
\chapter{Privileged Interface}

The privileged interface of the TCU adds support for virtual memory and PE sharing to the TCU. The
interface consists of multiple privileged registers, privileged commands, and \emph{core requests},
which are raised by the TCU and answered by the privileged software. The TCU stores the id of the
current VPE including the number of unread messages in all its receive EPs in the \texttt{CUR\_VPE}
register:

\begin{register}{H}{CUR\_VPE}{\texttt{0xF000\_1020}}
  \regfieldb[gray!20]{reserved}{32}{32}%
  \regfieldb{msgs}{16}{16}%
  \regfieldb{id}{16}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[msgs] the sum of all unread messages in the receive EPs for this VPE
    \item[id] the VPE id
  \end{reglist}\end{regdesc}
\end{register}

\noindent To support the privileged software in the management of multiple VPEs, privileged commands
are used, which can be performed by writing to \texttt{PRIV\_CMD}. The register is defined as
follows:

\begin{register}{H}{PRIV\_CMD}{\texttt{0xF000\_1010}}
  \regfieldb{arg}{60}{4}%
  \regfieldb{op}{4}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[arg] the argument for the privileged command
    \item[op] the opcode of the privileged command
  \end{reglist}\end{regdesc}
\end{register}

\section{Command List}

The following privileged commands are supported with the opcodes in parentheses:

\begin{itemize}
  \item \texttt{INV\_PAGE} (1): invalidate a page in the TLB,
  \item \texttt{INV\_TLB} (2): invalidate the complete TLB,
  \item \texttt{INS\_TLB} (3): insert an entry into the TLB,
  \item \texttt{XCHG\_VPE} (4): change the VPE,
  \item \texttt{SET\_TIMER} (5): start/stop the timer,
  \item \texttt{ABORT\_CMD} (6): abort the unprivileged command.
\end{itemize}

\section{Pseudo Code Building Blocks}

The following sections use pseudo code to describe the behavior of the privileged commands, based on
several building blocks:

\begin{itemize}
  \item \texttt{insert\_tlb\_entry(asid, virt, phys, flags)}:\\
  inserts an entry from \texttt{virt} to \texttt{phys} into the TLB for address space \texttt{asid}
  \item \texttt{remove\_tlb\_entry(asid, virt)}:\\
  removes the entry with \texttt{virt} in address space \texttt{asid}
  \item \texttt{clear\_tlb()}:\\
  removes all entries from the TLB
  \item \texttt{set\_timer(timeout)}:\\
  starts/restarts the timer to fire an interrupt after \texttt{timeout} nanoseconds
  \item \texttt{unset\_timer()}:\\
  stops the timer
  \item \texttt{waiting\_for\_resp() -> bool}:\\
  returns whether the TCU is currently waiting for a remote TCU's response (to \texttt{SEND},
  \texttt{REPLY}, \texttt{READ}, or \texttt{WRITE})
  \item \texttt{wait\_for\_resp()}:\\
  waits until a remote TCU responds (to \texttt{SEND}, \texttt{REPLY}, \texttt{READ}, or
  \texttt{WRITE})
  \item \texttt{abort\_remote\_xfer()}:\\
  lets the current remote transfer fail, so that \texttt{read\_remote()} or \texttt{write\_remote()}
  return the error ABORT (see \rref{sec:unprivcmdspseudo})
  \item \texttt{abort\_local\_xfer() -> bool}:\\
  checks if there is a local transfer (for the current unprivileged command) and if so, aborts it,
  so that \texttt{read\_local()} or \texttt{write\_local()} return the error ABORT (see
  \rref{sec:unprivcmdspseudo}). Returns true if it was aborted
\end{itemize}

\section{Command Description}

\todo{think about virtual address width}
\todo{document asid width}

\subsection{\texttt{INV\_PAGE}}

\begin{algorithm}[H]
    $asid \gets PRIV\_CMD.arg0 >> 44$\;
    $virt \gets PRIV\_CMD.arg0\ \&\ 0xFFF\_FFFF\_FFFF$\;
    \BlankLine
    $remove\_tlb\_entry(asid, virt)$\;
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{INV\_PAGE} command.}
\end{algorithm}

\subsection{\texttt{INV\_TLB}}

\begin{algorithm}[H]
    $clear\_tlb()$\;
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{INV\_TLB} command.}
\end{algorithm}

\subsection{\texttt{INS\_TLB}}

\begin{algorithm}[H]
    $asid \gets PRIV\_CMD.arg0 >> 44$\;
    $virt \gets PRIV\_CMD.arg0\ \&\ 0xFFF\_FFFF\_F000$\;
    $flags \gets PRIV\_CMD.arg0\ \&\ 0x1F$\;
    $phys \gets PRIV\_CMD\_ARG1$\;
    \BlankLine
    $insert\_tlb\_entry(asid, virt, phys, flags)$\;
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{INS\_TLB} command.}
\end{algorithm}

\subsection{\texttt{XCHG\_VPE}}

\begin{algorithm}[H]
    $old \gets CUR\_VPE$\;
    $OLD\_VPE \gets old$\;
    $CUR\_VPE \gets PRIV\_CMD.arg0\ \&\ 0xFFFF\_FFFF$\;
    \BlankLine
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{XCHG\_VPE} command.}
\end{algorithm}

\subsection{\texttt{SET\_TIMER}}

\begin{algorithm}[H]
    $nanos \gets PRIV\_CMD.arg0$\;
    \uIf{nanos == 0}{
      $unset\_timer()$\;
    }
    \uElse{
      $set\_timer(nanos)$\;
    }
    \BlankLine
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{SET\_TIMER} command.}
\end{algorithm}

\subsection{\texttt{ABORT\_CMD}}

\begin{algorithm}[H]
    \uIf{COMMAND.op != 0}{
      \uIf{waiting\_for\_resp()}{
        \uIf{COMMAND.op == READ or COMMAND.op == WRITE}{
          $PRIV\_CMD.arg0 \gets 1$\;
          $abort\_remote\_xfer()$\;
        }
        $wait\_for\_resp()$\;
      }
      \uElseIf{abort\_local\_xfer()}{
        $PRIV\_CMD.arg0 \gets 1$\;
      }
    }
    \BlankLine
    $PRIV\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{ABORT\_CMD} command.}
\end{algorithm}

\section{Core Requests}

With the privileged interface to support virtual memory and PE sharing, the TCU needs assistance of
the CU in some cases. Since we assume in this case that the CU is a general-purpose core, we call
these requests for assistance \emph{core requests}. Core requests are needed, for example, if a
message for another VPE than the currently running VPE (\texttt{CUR\_VPE}) is received.

Since multiple core requests might occur simultaneously, the TCU keeps a queue of pending core
requests and handles them in FIFO order. To handle the first in the queue, the TCU writes to
\texttt{CORE\_REQ} and injects an interrupt to inform the core about the request. After the handling
of the core request, the core is expected to write to \texttt{CORE\_REQ} again to signal the
completion of the request. Upon receiving this signal, the TCU issues the next core request, if
there is any. New core requests are appended to the queue via \texttt{queue\_foreign\_msg\_req()}
(see \rref{sec::unprivcmdspseudo}) and \texttt{queue\_xlate\_req()} (see \rref{todo}).

\begin{register}{H}{CORE\_REQ}{\texttt{0xF000\_1000}}
  \regfieldb[gray!60]{}{63}{1}%
  \regfieldb{type}{1}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[type] the type of CU request (0 = translation, 1 = foreign message)
  \end{reglist}\end{regdesc}
\end{register}

\noindent As the \texttt{CORE\_REQ} register is used for different kinds of requests and responses,
most of the bits depend on the type of request/response, defined in the following.

\begin{register}{H}{CORE\_REQ for translation requests}{\texttt{0xF000\_1000}}
  \regfieldb{vpe}{16}{48}%
  \regfieldb{virt}{36}{12}%
  \regfieldb[gray!20]{reserved}{8}{4}%
  \regfieldb{access}{2}{2}%
  \regfieldb{pf}{1}{1}%
  \regfieldb{type}{1}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[pf] whether the translation may page fault or should fail in this case
    \item[access] the requested access permissions (see \rref{sec:tlb})
    \item[virt] the virtual address to translate (shifted right by 12 bits)
    \item[vpe] the id of the VPE for whom to perform the translation
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{CORE\_REQ for translation responses}{\texttt{0xF000\_1000}}
  \regfieldb{phys}{52}{12}%
  \regfieldb[gray!20]{reserved}{7}{5}%
  \regfieldb{flags}{5}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[flags] the flags for the TLB entry (see \rref{sec:tlb})
    \item[phys] the physical address for the TLB entry
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{CORE\_REQ for foreign message requests}{\texttt{0xF000\_1000}}
  \regfieldb{vpe}{16}{48}%
  \regfieldb[gray!20]{reserved}{31}{17}%
  \regfieldb{ep}{16}{1}%
  \regfieldb{type}{1}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[ep] the receive EP which received a message
    \item[vpe] the VPE that received the message
  \end{reglist}\end{regdesc}
\end{register}

\begin{register}{H}{CORE\_REQ for foreign message responses}{\texttt{0xF000\_1000}}
  \regfieldb[gray!20]{reserved}{64}{0}\regnewline%
\end{register}

\cbend

\chapter{External Interface}

The external interface of the TCU allows remote PEs to manipulate its state. First of all, the TCU
can be made privileged or unprivileged through the \texttt{FEATURES} register, which has the
following format:

\setlength{\regWidth}{.95\textwidth}
\begin{register}{H}{\texttt{FEATURES}}{0xF000\_0000}
  \regfield[gray!20]{reserved}{63}{1}{{uninitialized}}%
  \regfield{kernel}{1}{0}{1}%
  \reglabel{Reset}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[kernel] whether the TCU belongs to a kernel PE
  \end{reglist}\end{regdesc}
\end{register}
\setlength{\regWidth}{\textwidth}

\noindent In other words, the \texttt{FEATURES} register currently only defines whether the TCU
belongs to a kernel PE. At reset, \texttt{FEATURES.kernel} is set to 1, so that all PEs are kernel
PEs. The software starting on one PE can afterwards downgrade the other PEs to user PEs.

If \texttt{FEATURES.kernel} is 1, the CU can write to endpoint registers. This can be used to create
a communication channel to the TCU's MMIO region in another PE, which allows to establish other
communication channels by writing to the endpoint registers within the MMIO region.

Additionally, the TCU supports \emph{external commands}, which are triggered by writing to the
\texttt{EXT\_CMD} register and feedback is given via this register as well. The \texttt{EXT\_CMD}
register has the following format:

\begin{register}{H}{EXT\_CMD}{\texttt{0xF000\_0008}}
  \regfieldb{arg}{56}{8}%
  \regfieldb{err}{4}{4}%
  \regfieldb{op}{4}{0}\regnewline%
  \begin{regdesc}\begin{reglist}
    \item[arg] an argument for the operation
    \item[err] the result of the operation (output field)
    \item[op] the operation to execute
  \end{reglist}\end{regdesc}
\end{register}

\section{Command List}

The TCU supports the following external commands with the opcodes in parentheses:

\begin{itemize}
  \item \texttt{INV\_EP} (1): invalidate an endpoint.
\end{itemize}

\section{Pseudo Code Building Blocks}
\label{sec:extcmdspseudo}

The following sections use pseudo code to describe the behavior of the external TCU commands, based
on the following building blocks:

\begin{itemize}
  \item \texttt{ext\_fail(error)}:\\
  stop the execution of the external command by setting the opcode in \texttt{EXT\_CMD} to 0 and the
  error code to the given error.
\end{itemize}

\section{Command Description}

\subsection{\texttt{INV\_EP}}

\begin{algorithm}[H]
    $epid \gets EXT\_CMD.arg\ \&\ 0xFFFF$\;
    $force \gets EXT\_CMD.arg >> 16$\;
    \BlankLine
    $EXT\_CMD.arg \gets 0$\;
    \BlankLine
    $ep \gets$ read\_ep(epid)\;
    \uIf{force == 0 and ep.type == SEND}{
      \uIf{ep.cur\_crd != ep.max\_crd}{ext\_fail(MISS\_CREDITS)}
    }
    \uIf{force == 0 and ep.type == RECEIVE}{
      $EXT\_CMD.arg \gets ep.unread$\;
    }
    \BlankLine
    $ep \gets \{~type \gets INVALID~\}$\;
    $write\_ep(epid, ep)$\;
    \BlankLine
    $EXT\_CMD.err \gets 0$\;
    $EXT\_CMD.op \gets 0$\;
    \caption{The TCU's \texttt{INV\_EP} command.}
\end{algorithm}

\end{document}
